<!DOCTYPE html>
<html lang="en">
<head>
    <meta content="width=device-width, initial-scale=1" name="viewport" >
    <meta charset="UTF-8">
    <link rel="shortcut icon" href="favicon.ico">
    <script src="./coi-serviceworker.js"></script>
    <style>
        body, html { 
            width: 100vw; height: 100vh; overflow: hidden;
            margin: 0; overscroll-behavior-x: none;
            background-color: #08203f;
            pointer-events: none;
        }

        body::after {
            content: attr(title);
            transform: translate(-70px, -100px) rotateZ(-90deg);
            position: fixed;
            left: 0;
            bottom: 0;
            color: rgb(169, 229, 19);
            font-family: Georgia, 'Times New Roman', Times, serif;
            font-size: 18px;
            white-space: nowrap;
        }

    </style>

</head>
<body title="146.853.146.838 ops/sec">    

<script src="Optr.js">

    const onscreen = new OnscreenCanvas()
    let red = 0.1, green = 0.3 , blue= 0.9, sign = 1, factor = 0.002;
    let valueset = new Float32Array([
                // left column front
                 0,   0,  0,
                 0, 150,  0,
                30,   0,  0,
                 0, 150,  0,
                30, 150,  0,
                30,   0,  0,

                // top rung front
                 30,   0,  0,
                 30,  30,  0,
                100,   0,  0,
                 30,  30,  0,
                100,  30,  0,
                100,   0,  0,

                // middle rung front
                30,  60,  0,
                30,  90,  0,
                67,  60,  0,
                30,  90,  0,
                67,  90,  0,
                67,  60,  0,

                // left column back
                 0,   0,  30,
                30,   0,  30,
                 0, 150,  30,
                 0, 150,  30,
                30,   0,  30,
                30, 150,  30,

                // top rung back
                 30,   0,  30,
                100,   0,  30,
                 30,  30,  30,
                 30,  30,  30,
                100,   0,  30,
                100,  30,  30,

                // middle rung back
                30,  60,  30,
                67,  60,  30,
                30,  90,  30,
                30,  90,  30,
                67,  60,  30,
                67,  90,  30,

                // top
                  0,   0,   0,
                100,   0,   0,
                100,   0,  30,
                  0,   0,   0,
                100,   0,  30,
                  0,   0,  30,

                // top rung right
                100,   0,   0,
                100,  30,   0,
                100,  30,  30,
                100,   0,   0,
                100,  30,  30,
                100,   0,  30,

                // under top rung
                30,   30,   0,
                30,   30,  30,
                100,  30,  30,
                30,   30,   0,
                100,  30,  30,
                100,  30,   0,

                // between top rung and middle
                30,   30,   0,
                30,   60,  30,
                30,   30,  30,
                30,   30,   0,
                30,   60,   0,
                30,   60,  30,

                // top of middle rung
                30,   60,   0,
                67,   60,  30,
                30,   60,  30,
                30,   60,   0,
                67,   60,   0,
                67,   60,  30,

                // right of middle rung
                67,   60,   0,
                67,   90,  30,
                67,   60,  30,
                67,   60,   0,
                67,   90,   0,
                67,   90,  30,

                // bottom of middle rung.
                30,   90,   0,
                30,   90,  30,
                67,   90,  30,
                30,   90,   0,
                67,   90,  30,
                67,   90,   0,

                // right of bottom
                30,   90,   0,
                30,  150,  30,
                30,   90,  30,
                30,   90,   0,
                30,  150,   0,
                30,  150,  30,

                // bottom
                0,   150,   0,
                0,   150,  30,
                30,  150,  30,
                0,   150,   0,
                30,  150,  30,
                30,  150,   0,

                // left side
                0,   0,   0,
                0,   0,  30,
                0, 150,  30,
                0,   0,   0,
                0, 150,  30,
                0, 150,   0,
            ]);


    onscreen.oncontextrestored = function ( gl ){

        log(gl)

        gl.viewport( 0, 0, this.width, this.height )
        ui.viewport( 0, 0, this.width, this.height )
            .perspective( 90, 1e-2, 1e3 )
            .setMovementsPerSecond( 1, 1, 1 )
            .setRotationsPerSecond( .1, .1, .1 )

        

        const triangle = this.malloc( valueset.length / 3 );

        triangle.set( valueset )



        ui.matrix = ui.matrix.translateSelf(
            0, 0, .1
        )



        gl.u_ViewMatrix = ui.matrix;
        gl.u_PointSize = 10;

        setTimeout(function (){

            gl.u_PointSize = 10;
            warn({ drawBuffer: ui.matrix })

        }, 3000)

    };

    const applyMovements = function ( delta ) {

        if ( ui.moveForth ) {
            ui.matrix.translateSelf(
                ui.moveForth * delta  * ui.xMovementPerSecond
            )
        }
    }
    
    onscreen.render(function (gl, delta){

        if ( ui.hasEvent ) {
            applyMovements( delta )
            gl.u_ViewMatrix = ui.matrix
        }

        red += (factor * sign);
        green += (factor * sign);
        blue += (factor * sign); 

        if ( red > 1 || red < 0 ) { sign *= -1; }
        if ( green > 1 || green < 0 ) { sign *= -1; }
        if ( blue > 1 || blue < 0 ) { sign *= -1; }

        gl.clearColor( red, green, blue, 1 );
        gl.clearDepth(1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    });


    /*


        function numberWithCommas(x) {
            var parts = x.toString().split(".");
            parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ".");
            return parts.join(".");
        }

        <canvas id="bitmaprenderer" width="256" height="256" ></canvas>


        const offscreen = new OffscreenCanvas(256, 256);
        const gl = offscreen.getContext("webgl2");

        let red = 0, green = 0.5 , blue= 0.3, sign = 1, factor = 0.01;

        offscreen.render(function (){

            red += (factor * sign);
            green += (factor * sign);
            blue += (factor * sign); 

            if ( red > 1 || red < 0 ) { sign *= -1; }
            if ( green > 1 || green < 0 ) { sign *= -1; }
            if ( blue > 1 || blue < 0 ) { sign *= -1; }

            gl.clearColor( red, green, blue, 1 );
            gl.clear(gl.COLOR_BUFFER_BIT);

        });
    
        log({ offscreen, gl });



    
        let a = new Uint8Array(9999999999);
        console.warn( name, "\t--> HPC code running...",  {a} );
    
        let t0;
        if ( isBridge ) {
            t0 = performance.now();
        }

        let retry = 20;
        let tried = 1;


        while ( retry-- ) {
            for ( let i of a ) {
                //a[i] = 0xffffff * Math.random()
                a[i] = 1;
                //a[i] = Math.random() * 0xff
                //a[i] = BigInt( Math.trunc(Math.random() * 0xffffffff) )
            }
            tried++;
        }

        if ( isBridge ) {
            let msecs = performance.now() - t0; 
            let count = a.length;
            let ops = tried * count;
            let secs = (msecs / 1000).toFixed(2) * 1;
            let ratio = Math.trunc(ops / secs);

            let nice = numberWithCommas(ratio) + " ops/sec";

            console.table({
                nice, msecs, tried, count, ops, secs, ratio
            })

            console.log( a )
        }

    */

</script>
<script>
        /*
        let now;
        let count = 3;
        let testArray8 = new Uint8Array();

        //console.log(name, "\t", testArray8)
        
        // 15x faster then inop
        let ofop = function (c) {
            now = performance.now()

            for ( let i of testArray8) {
                testArray8[i] = Math.floor(Math.random() * 255)
            }

            if (--c)
                return ofop(c)
        }

        // sooo slowww we slicing keys to cpu's
        let inop = function (c) {
            now = performance.now()

            for ( let i in testArray8) {
                testArray8[i] = Math.floor(Math.random() * 255)
            }

            if (--c)
                return ofop(c)
        }

        ofop( count )

        console.log(name, "\t", "get", testArray8)

        if (self.isBridge) {

            let msec = performance.now() - now;
            let sec = parseFloat((1e-3 * msec).toFixed(2));
            let op = (testArray8.length * count);
            let ratio = Math.trunc( op/(msec/1e3) );
            let iterated = count;

            console.warn( name, "done:", sec, "secs", op, "ops", ratio, "op/sec", "in", iterated, "iteration" );

            setTimeout(function (){
                    console.log(testArray8.array)
            }, 100)
        }

        //console.log(name, "\t", "get BYTES_PER_ELEMENT:", testArray8.BYTES_PER_ELEMENT)
        //console.log(name, "\t", "set 0 = 1", testArray8[0] = 1)
    */

</script>
<script>
    /*
    ###
    self.isWindow = Boolean document?;

    unless SharedArrayBuffer?
        throw /SHARED_ARRAY_BUFFER_NOT_AVAILABLE/

    import "./prototype.js"

    basepath = location.href.replace('/index.html', '')

    for script in document.scripts
        if `import.meta.url` is script.src
            break if script = "#{script.text}"
    unless script then throw "?CODE?"

    onrequest   = ( i, e ) ->
        { func , args , lock } = e.data

        ( root = self )

        for prop in func
            root = root[ prop ]

        func = root.bind self[ func[ 0 ] ] 
        call = func( ...args )

        Atomics.add this, 0 , 1
        Atomics.store this, i , 10000 * Math.random()
        Atomics.notify this, i, 1

    addEventListener "message", ({ data }) ->
        console.log 2, data

        #? window gets message that means some remote
        #? controller connected to this device
        #? so, we need to do what we do 
        buffer = new SharedArrayBuffer data

        #* at this point, memory is initialized
        console.warn "[#{self.constructor.name}]", performance.now(2), "memory is initialized", buffer


    cpuCount = Math.max( 
        2, ( navigator?.hardwareConcurrency or 2 ) - 2
    )

    #cpuCount = 2

    addEventListener "load", ->

        cpuURL = URL.createWorkerURL "
            self.isCPU = true;
            self.cpuCount = #{cpuCount};

            import '#{basepath}/prototype.js';
            import '#{basepath}/0ptr_window.js';

            addEventListener( 'message', function ({ data }){
                self.memory = data.memory.defineProperties();                        
                self.postMessage(0);
                memory.lock(3);
                console.error('cpu unlocked', name );
                #{script}                        
            });
        "

        self.bridge = new Worker URL.createWorkerURL "
            self.isBridge = true;
            self.cpuCount = #{cpuCount};

            import '#{basepath}/prototype.js';
            import '#{basepath}/0ptr_window.js';
                    
            self.memory = new SharedArrayBuffer();
            self.postMessage({ memory: self.memory, name });

            memory.lock(4);
            console.warn( 'bridge unlocked:', name );
            
            #{script}
        "

        bridge.addEventListener "message", ({ data }) ->

            self.memory = data.memory.defineProperties();
            console.warn( 'bridge ready:', data.name );


            waiting = cpuCount
            forking = cpuCount 
            threads = []

            while forking--
                
                cpu = new Worker cpuURL, "cpu" + forking

                cpu . onmessage = ({ data: i }) ->
                    threads.push this

                    return if --waiting
                    requestIdleCallback ->
                        memory.unlock(3)

                    memory.unlock(4)
                                                                        
                cpu . postMessage({ memory: self.memory });

            self.onclick = -> console.log threads
    ###*/
</script>
</body>
</html>