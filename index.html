<!DOCTYPE html>
<html lang="en">
<head>
    <meta content="width=device-width, initial-scale=1" name="viewport" >
    <meta charset="UTF-8">
    <link rel="shortcut icon" href="favicon.ico">
    <script src="./coi-serviceworker.js"></script>
    <style>
        body, html { 
            width: 100vw; height: 100vh; overflow: hidden;
            margin: 0; overscroll-behavior-x: none;
            background-color: #0f3057;
        }
    </style>

</head>
<body>
<canvas id="viewport"></canvas>
<script src="Optr.js" name="0ptr" type="module">
console.log( "HPC code will run on:", {name, memory, document});
</script>
<script>
        /*
        let now;
        let count = 3;
        let testArray8 = new Uint8Array();

        //console.log(name, "\t", testArray8)
        
        // 15x faster then inop
        let ofop = function (c) {
            now = performance.now()

            for ( let i of testArray8) {
                testArray8[i] = Math.floor(Math.random() * 255)
            }

            if (--c)
                return ofop(c)
        }

        // sooo slowww we slicing keys to cpu's
        let inop = function (c) {
            now = performance.now()

            for ( let i in testArray8) {
                testArray8[i] = Math.floor(Math.random() * 255)
            }

            if (--c)
                return ofop(c)
        }

        ofop( count )

        console.log(name, "\t", "get", testArray8)

        if (self.isBridge) {

            let msec = performance.now() - now;
            let sec = parseFloat((1e-3 * msec).toFixed(2));
            let op = (testArray8.length * count);
            let ratio = Math.trunc( op/(msec/1e3) );
            let iterated = count;

            console.warn( name, "done:", sec, "secs", op, "ops", ratio, "op/sec", "in", iterated, "iteration" );

            setTimeout(function (){
                    console.log(testArray8.array)
            }, 100)
        }

        //console.log(name, "\t", "get BYTES_PER_ELEMENT:", testArray8.BYTES_PER_ELEMENT)
        //console.log(name, "\t", "set 0 = 1", testArray8[0] = 1)
    */

</script>
<script>
    /*
    ###
    self.isWindow = Boolean document?;

    unless SharedArrayBuffer?
        throw /SHARED_ARRAY_BUFFER_NOT_AVAILABLE/

    import "./prototype.js"

    basepath = location.href.replace('/index.html', '')

    for script in document.scripts
        if `import.meta.url` is script.src
            break if script = "#{script.text}"
    unless script then throw "?CODE?"

    onrequest   = ( i, e ) ->
        { func , args , lock } = e.data

        ( root = self )

        for prop in func
            root = root[ prop ]

        func = root.bind self[ func[ 0 ] ] 
        call = func( ...args )

        Atomics.add this, 0 , 1
        Atomics.store this, i , 10000 * Math.random()
        Atomics.notify this, i, 1

    addEventListener "message", ({ data }) ->
        console.log 2, data

        #? window gets message that means some remote
        #? controller connected to this device
        #? so, we need to do what we do 
        buffer = new SharedArrayBuffer data

        #* at this point, memory is initialized
        console.warn "[#{self.constructor.name}]", performance.now(2), "memory is initialized", buffer


    cpuCount = Math.max( 
        2, ( navigator?.hardwareConcurrency or 2 ) - 2
    )

    #cpuCount = 2

    addEventListener "load", ->

        cpuURL = URL.createWorkerURL "
            self.isCPU = true;
            self.cpuCount = #{cpuCount};

            import '#{basepath}/prototype.js';
            import '#{basepath}/0ptr_window.js';

            addEventListener( 'message', function ({ data }){
                self.memory = data.memory.defineProperties();                        
                self.postMessage(0);
                memory.lock(3);
                console.error('cpu unlocked', name );
                #{script}                        
            });
        "

        self.bridge = new Worker URL.createWorkerURL "
            self.isBridge = true;
            self.cpuCount = #{cpuCount};

            import '#{basepath}/prototype.js';
            import '#{basepath}/0ptr_window.js';
                    
            self.memory = new SharedArrayBuffer();
            self.postMessage({ memory: self.memory, name });

            memory.lock(4);
            console.warn( 'bridge unlocked:', name );
            
            #{script}
        "

        bridge.addEventListener "message", ({ data }) ->

            self.memory = data.memory.defineProperties();
            console.warn( 'bridge ready:', data.name );


            waiting = cpuCount
            forking = cpuCount 
            threads = []

            while forking--
                
                cpu = new Worker cpuURL, "cpu" + forking

                cpu . onmessage = ({ data: i }) ->
                    threads.push this

                    return if --waiting
                    requestIdleCallback ->
                        memory.unlock(3)

                    memory.unlock(4)
                                                                        
                cpu . postMessage({ memory: self.memory });

            self.onclick = -> console.log threads
    ###*/
</script>
</body>
</html>