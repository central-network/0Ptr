<!DOCTYPE html>
<html lang="en">
<head>
    <meta content="width=device-width, initial-scale=1" name="viewport" >
    <meta charset="UTF-8">
    <link rel="shortcut icon" href="favicon.ico">
    <script src="./coi-serviceworker.js"></script>
    <style>
        body, html { 
            width: 100vw; height: 100vh; overflow: hidden;
            margin: 0; overscroll-behavior-x: none;
            background-color: #08203f;
            pointer-events: none;
        }

        body::after {
            content: attr(title);
            transform: translate(-70px, -100px) rotateZ(-90deg);
            position: fixed;
            left: 0;
            bottom: 0;
            color: rgb(169, 229, 19);
            font-family: Georgia, 'Times New Roman', Times, serif;
            font-size: 18px;
            white-space: nowrap;
        }

    </style>

</head>
<body title="146.853.146.838 ops/sec">    

<script src="Optr.js">

    const onscreen = new OnscreenCanvas()
    let red = 0.1, green = 0.3 , blue= 0.9, sign = 1, factor = 0.002;




    onscreen.oncontextrestored = function ( gl ){

        gl.viewport( 0, 0, this.width, this.height )
        ui.viewport( 0, 0, this.width, this.height )
            .perspective( 60, .01, 1000 )


        const triangle = this.malloc( 3 );

        triangle.set([
            1, -1, 0,
            -1, -1, 0,
            0, 1, 0
        ])

        console.log(ui)
        

        setTimeout(function (){
            triangle.set([
                121232, -121232, 210,
                -121232, -122123, 210,
                1212330, 123122, 123210
            ])
            log(triangle)

        }, 3000)

    };

    
    log( ui)

    onscreen.render(function (gl){

        red += (factor * sign);
        green += (factor * sign);
        blue += (factor * sign); 

        if ( red > 1 || red < 0 ) { sign *= -1; }
        if ( green > 1 || green < 0 ) { sign *= -1; }
        if ( blue > 1 || blue < 0 ) { sign *= -1; }

        gl.clearColor( red, green, blue, 1 );
        gl.clear(gl.COLOR_BUFFER_BIT);

    });


    /*


        function numberWithCommas(x) {
            var parts = x.toString().split(".");
            parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ".");
            return parts.join(".");
        }

        <canvas id="bitmaprenderer" width="256" height="256" ></canvas>


        const offscreen = new OffscreenCanvas(256, 256);
        const gl = offscreen.getContext("webgl2");

        let red = 0, green = 0.5 , blue= 0.3, sign = 1, factor = 0.01;

        offscreen.render(function (){

            red += (factor * sign);
            green += (factor * sign);
            blue += (factor * sign); 

            if ( red > 1 || red < 0 ) { sign *= -1; }
            if ( green > 1 || green < 0 ) { sign *= -1; }
            if ( blue > 1 || blue < 0 ) { sign *= -1; }

            gl.clearColor( red, green, blue, 1 );
            gl.clear(gl.COLOR_BUFFER_BIT);

        });
    
        log({ offscreen, gl });



    
        let a = new Uint8Array(9999999999);
        console.warn( name, "\t--> HPC code running...",  {a} );
    
        let t0;
        if ( isBridge ) {
            t0 = performance.now();
        }

        let retry = 20;
        let tried = 1;


        while ( retry-- ) {
            for ( let i of a ) {
                //a[i] = 0xffffff * Math.random()
                a[i] = 1;
                //a[i] = Math.random() * 0xff
                //a[i] = BigInt( Math.trunc(Math.random() * 0xffffffff) )
            }
            tried++;
        }

        if ( isBridge ) {
            let msecs = performance.now() - t0; 
            let count = a.length;
            let ops = tried * count;
            let secs = (msecs / 1000).toFixed(2) * 1;
            let ratio = Math.trunc(ops / secs);

            let nice = numberWithCommas(ratio) + " ops/sec";

            console.table({
                nice, msecs, tried, count, ops, secs, ratio
            })

            console.log( a )
        }

    */

</script>
<script>
        /*
        let now;
        let count = 3;
        let testArray8 = new Uint8Array();

        //console.log(name, "\t", testArray8)
        
        // 15x faster then inop
        let ofop = function (c) {
            now = performance.now()

            for ( let i of testArray8) {
                testArray8[i] = Math.floor(Math.random() * 255)
            }

            if (--c)
                return ofop(c)
        }

        // sooo slowww we slicing keys to cpu's
        let inop = function (c) {
            now = performance.now()

            for ( let i in testArray8) {
                testArray8[i] = Math.floor(Math.random() * 255)
            }

            if (--c)
                return ofop(c)
        }

        ofop( count )

        console.log(name, "\t", "get", testArray8)

        if (self.isBridge) {

            let msec = performance.now() - now;
            let sec = parseFloat((1e-3 * msec).toFixed(2));
            let op = (testArray8.length * count);
            let ratio = Math.trunc( op/(msec/1e3) );
            let iterated = count;

            console.warn( name, "done:", sec, "secs", op, "ops", ratio, "op/sec", "in", iterated, "iteration" );

            setTimeout(function (){
                    console.log(testArray8.array)
            }, 100)
        }

        //console.log(name, "\t", "get BYTES_PER_ELEMENT:", testArray8.BYTES_PER_ELEMENT)
        //console.log(name, "\t", "set 0 = 1", testArray8[0] = 1)
    */

</script>
<script>
    /*
    ###
    self.isWindow = Boolean document?;

    unless SharedArrayBuffer?
        throw /SHARED_ARRAY_BUFFER_NOT_AVAILABLE/

    import "./prototype.js"

    basepath = location.href.replace('/index.html', '')

    for script in document.scripts
        if `import.meta.url` is script.src
            break if script = "#{script.text}"
    unless script then throw "?CODE?"

    onrequest   = ( i, e ) ->
        { func , args , lock } = e.data

        ( root = self )

        for prop in func
            root = root[ prop ]

        func = root.bind self[ func[ 0 ] ] 
        call = func( ...args )

        Atomics.add this, 0 , 1
        Atomics.store this, i , 10000 * Math.random()
        Atomics.notify this, i, 1

    addEventListener "message", ({ data }) ->
        console.log 2, data

        #? window gets message that means some remote
        #? controller connected to this device
        #? so, we need to do what we do 
        buffer = new SharedArrayBuffer data

        #* at this point, memory is initialized
        console.warn "[#{self.constructor.name}]", performance.now(2), "memory is initialized", buffer


    cpuCount = Math.max( 
        2, ( navigator?.hardwareConcurrency or 2 ) - 2
    )

    #cpuCount = 2

    addEventListener "load", ->

        cpuURL = URL.createWorkerURL "
            self.isCPU = true;
            self.cpuCount = #{cpuCount};

            import '#{basepath}/prototype.js';
            import '#{basepath}/0ptr_window.js';

            addEventListener( 'message', function ({ data }){
                self.memory = data.memory.defineProperties();                        
                self.postMessage(0);
                memory.lock(3);
                console.error('cpu unlocked', name );
                #{script}                        
            });
        "

        self.bridge = new Worker URL.createWorkerURL "
            self.isBridge = true;
            self.cpuCount = #{cpuCount};

            import '#{basepath}/prototype.js';
            import '#{basepath}/0ptr_window.js';
                    
            self.memory = new SharedArrayBuffer();
            self.postMessage({ memory: self.memory, name });

            memory.lock(4);
            console.warn( 'bridge unlocked:', name );
            
            #{script}
        "

        bridge.addEventListener "message", ({ data }) ->

            self.memory = data.memory.defineProperties();
            console.warn( 'bridge ready:', data.name );


            waiting = cpuCount
            forking = cpuCount 
            threads = []

            while forking--
                
                cpu = new Worker cpuURL, "cpu" + forking

                cpu . onmessage = ({ data: i }) ->
                    threads.push this

                    return if --waiting
                    requestIdleCallback ->
                        memory.unlock(3)

                    memory.unlock(4)
                                                                        
                cpu . postMessage({ memory: self.memory });

            self.onclick = -> console.log threads
    ###*/
</script>
</body>
</html>