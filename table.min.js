var error, log, table, warn;

import * as OPTR from "./0ptr.min.js";

({log, warn, error, table} = console);

export var Database = (function() {
  class Database extends OPTR.ObjectPointer {
    static create(name) {
      return Object.assign(this.new(), {name});
    }

    createTable(name, pages) {
      return this.appendChild(Object.assign(Table.new(), {
        pages,
        name,
        base: OPTR.Uint8ArrayPointer.from(pages * 654)
      }));
    }

    createOperation() {
      return Operation.from(...arguments);
    }

    parseColumns({columns = "*"}, tables = {}) {
      var alias, c, colName, columnName, columnNames, len, len1, matchs, o, q, ref1, t, tAlias, tableAlias, tablesColumns;
      if (columns.match(/\*/)) {
        tablesColumns = [];
        for (tAlias in tables) {
          t = tables[tAlias];
          ref1 = t.children;
          for (o = 0, len = ref1.length; o < len; o++) {
            c = ref1[o];
            tablesColumns.push(`${tAlias}.${c.name.toPrimitive()}`);
          }
        }
        columns = columns.replace(/\*/g, tablesColumns.join(","));
      }
      columnNames = columns.split(/\,/);
      columnNames = columnNames.map(function(t) {
        return t.trim();
      });
      columnNames = columnNames.filter(function(c, i) {
        return columnNames.indexOf(c) === i;
      });
      columnNames = columnNames.filter(Boolean);
      columns = new Object;
      for (q = 0, len1 = columnNames.length; q < len1; q++) {
        columnName = columnNames[q];
        tableAlias = "";
        if (columnName.match(/\./)) {
          [tableAlias, colName] = columnName.split(/\./g).map(function(n) {
            return n.trim();
          }).filter(Boolean);
          if (!colName) {
            throw /TBL.COLNAME_COLMNFAILED/;
          }
          if (!tables[tableAlias]) {
            throw /TBL.COLNAME_TABLEFAILED/;
          }
          columnName = colName;
        }
        [colName, alias] = columnName.replace(/\s+|as/g, " ").split(/\s+/g);
        alias || (alias = colName);
        if (tableAlias) {
          columns[`${tableAlias}.${alias}`] = tables[tableAlias].children.find(function(c) {
            return c.name.eq(colName);
          });
          continue;
        }
        matchs = this.filter(function(t) {
          return t.find(function(c) {
            return c.name.eq(colName);
          });
        });
        switch (matchs.length) {
          case 1:
            tableAlias = matchs[0].name.toPrimitive();
            break;
          case 0:
            throw /TBLNOTFOUND_USEDCOLMNS/;
          default:
            throw /COLMNMATCHS_MULTITABLE/;
        }
        table = tables[tableAlias] || matchs.at(0);
        if (!(columns[`${tableAlias}.${alias}`] = table.children.find(function(c) {
          return c.name.eq(colName);
        }))) {
          throw /TBLFORCOL_NOTFOUND/;
        }
      }
      return columns;
    }

    parseTables({tables = ""}) {
      var alias, dbName, len, o, tableName, tableNames;
      tableNames = tables.split(/\,/);
      tableNames = tableNames.map(function(t) {
        return t.trim();
      });
      tableNames = tableNames.filter(Boolean);
      if (!tableNames.length) {
        throw /FROMARG_REQUIRED/;
      }
      tables = new Object;
      for (o = 0, len = tableNames.length; o < len; o++) {
        tableName = tableNames[o];
        [dbName, alias] = tableName.replace(/\s+|as/g, " ").split(/\s+/g);
        if (!alias) {
          alias = dbName;
        }
        if (!(table = this.find(function(t) {
          return t.name.eq(dbName);
        }))) {
          throw /TBL_NOTFOUND/;
        }
        tables[alias] = table;
      }
      return tables;
    }

    parseRules({rules = []}, columns, tables) {
      var alias, any, closed, contents, end, ends, getAny, getColumn, getNumber, i, index, len, len1, len2, len3, len4, len5, next, o, opened, p0, p1, part, part0, part1, parts, partsAll, partsSliced, prev, q, r, ref1, ref2, ref3, rule, ruleindex, ruleset, start, starts, u, v, w;
      ruleset = new Array;
      contents = new Array;
      getColumn = function(any) {
        var c, column;
        if (columns[any]) {
          return columns[any];
        }
        for (c in columns) {
          column = columns[c];
          if (column.name.eq(any)) {
            return column;
          }
        }
        for (c in columns) {
          column = columns[c];
          if (c.split(".").at(-1) === any) {
            return column;
          }
        }
        return void 0;
      };
      getNumber = function(any) {
        var number;
        if (isNaN(any)) {
          return;
        }
        number = Number(any);
        if (!Number.isInteger(number)) {
          return OPTR.Float32Number.from(number);
        }
        return OPTR.Int32Number.from(number);
      };
      getAny = function(any) {
        return Comparision.fromMatch(any) || Operator.fromMatch(any) || Mathematics.fromMatch(any) || getNumber(any) || getColumn(any);
      };
      for (ruleindex = o = 0, len = rules.length; o < len; ruleindex = ++o) {
        rule = rules[ruleindex];
        rule = `(${rule})`;
        parts = [];
        starts = [];
        ends = [];
        start = -1;
        end = rule.length + 1;
        opened = true;
        closed = true;
        while (opened || closed) {
          start = rule.indexOf("(", start + 1);
          end = rule.lastIndexOf(")", end - 1);
          opened = start !== -1;
          closed = end !== -1;
          if (opened) {
            starts.push(start);
          }
          if (closed) {
            ends.unshift(end);
          }
        }
        if (starts.length - ends.length) {
          throw [/RULEERR_PARANTHESIS/, rule, starts, ends];
        }
        ref1 = starts.reverse();
        for (i = q = 0, len1 = ref1.length; q < len1; i = ++q) {
          start = ref1[i];
          alias = "$part" + i;
          index = ends.findIndex(function(i) {
            return i > start;
          });
          end = ends.splice(index, 1).at(0);
          prev = rule.substring(0, start + 1);
          next = rule.substring(end);
          parts.push({
            start,
            end,
            alias,
            text: rule.substring(start + 1, end),
            prev,
            next
          });
        }
        partsSliced = parts.slice(0);
        partsAll = partsSliced.slice();
        for (p0 = r = 0, len2 = partsSliced.length; r < len2; p0 = ++r) {
          part0 = partsSliced[p0];
          ref2 = partsSliced.slice(p0);
          for (p1 = u = 0, len3 = ref2.length; u < len3; p1 = ++u) {
            part1 = ref2[p1];
            part1.subs || (part1.subs = []);
            if (part0.start > part1.start) {
              if (part0.end < part1.end) {
                part1.subs.push(part0);
                part0.parent = part1;
                break;
              }
            }
          }
        }
        parts = parts.at(-1).subs;
        for (i = v = 0, len4 = partsAll.length; v < len4; i = ++v) {
          part = partsAll[i];
          part.contents = [];
          ref3 = part.text.split(/\s+|\(|\)/g).filter(Boolean);
          for (w = 0, len5 = ref3.length; w < len5; w++) {
            any = ref3[w];
            part.contents.push(contents[contents.length] = {
              any: any,
              part: part,
              match: getAny(any)
            });
          }
        }
        ruleset.push({
          rule: rule.substring(1, rule.length - 1),
          parts,
          partsAll
        });
      }
      log(ruleset);
      log(columns);
      log(contents);
      return ruleset;
    }

    query(options = {}) {
      var column, columnAlias, columnName, columns, get, i, index, len, o, results, row, rows, rule, rules, tableAlias, tables, value;
      tables = this.parseTables(options);
      columns = this.parseColumns(options, tables);
      rules = this.parseRules(options, columns, tables);
      if (Object.keys(tables).length === 1) {
        for (columnAlias in columns) {
          column = columns[columnAlias];
          columns[columnAlias.split(".")[1]] = column;
          delete columns[columnAlias];
        }
      }
      results = [];
      index = 0;
      for (tableAlias in tables) {
        table = tables[tableAlias];
        rows = table.count;
        i = 0;
        while (i < rows) {
          get = table.get(i++);
          row = {};
          for (columnAlias in columns) {
            column = columns[columnAlias];
            columnName = column.name.toPrimitive();
            row[columnAlias] = get[columnName];
          }
          for (o = 0, len = rules.length; o < len; o++) {
            rule = rules[o];
            for (columnAlias in row) {
              value = row[columnAlias];
              //todo replace value with alias and filter
              1;
            }
          }
          results[index++] = row;
        }
      }
      return results;
    }

    getSourceRefs() {
      var col, colName, dbName, len, len1, o, q, ref1, ref2, sources, tbl, tblName;
      sources = {};
      dbName = this.name.toPrimitive();
      ref1 = this.children;
      for (o = 0, len = ref1.length; o < len; o++) {
        tbl = ref1[o];
        tblName = tbl.name.toPrimitive();
        ref2 = tbl.children;
        for (q = 0, len1 = ref2.length; q < len1; q++) {
          col = ref2[q];
          colName = col.name.toPrimitive();
          sources[`${dbName}.${tblName}.${colName}`] = sources[`${tblName}.${colName}`] = col;
          if (sources[colName]) {
            delete sources[colName];
          } else {
            sources[colName] = col;
          }
        }
        sources[`${dbName}.${tblName}`] = tbl;
        if (sources[tblName]) {
          delete sources[tblName];
        } else {
          sources[tblName] = tbl;
        }
      }
      return sources;
    }

    parse(query = "") {
      var items, parseColumns, parseMatches, parseSources, partRawQuery, repart, resolveParts, rquery, sources;
      items = new Array;
      sources = this.getSourceRefs();
      repart = function(parted) {
        var adopted, childs, closed, closer, closers, ctext, end, i, index, isAfter, isEarly, item, len, len1, len2, len3, len4, len5, length, match, o, opened, opener, openers, p0, p0text, p1, parent, part, parts, q, r, ref1, ref2, ref3, result, start, text, u, v, w;
        ctext = `(${parted.trim()})`;
        parts = [];
        ref1 = ctext.matchAll(/\(|\)|\[|\]|\{|\}|\`|\'|\"/g);
        for (part of ref1) {
          [match] = ({
            index: start
          } = part);
          ({
            length: index
          } = parts.filter(function(p) {
            return p.match === match;
          }));
          parts[parts.length] = {
            match,
            start,
            index,
            parents: new Array,
            children: new Array
          };
        }
        closers = [")", "]", "}"];
        openers = ["(", "[", "{", "'", "`", '"'];
        for (o = 0, len = parts.length; o < len; o++) {
          closed = parts[o];
          ({
            index,
            match: closer,
            start
          } = closed);
          (opener = openers[closers.indexOf(closer)]);
          if (!opener && !closers[openers.indexOf(closer)]) {
            opener = index % 2 ? closer : null;
          }
          opened = parts.filter(function(p) {
            return p.match === opener;
          }).filter(function(p) {
            return p.start < start;
          }).filter(function(p) {
            return p.end === void 0;
          }).at(-1);
          if (!opened) {
            continue;
          }
          opened.end = closed.start;
          opened.text = ctext.substring(opened.start, start + 1);
          opened.length = start - opened.start;
          opened.isString = opener === closer;
          delete opened.index;
        }
        ref2 = parts.filter(function(p) {
          return p.end;
        });
        for (q = 0, len1 = ref2.length; q < len1; q++) {
          p0 = ref2[q];
          for (r = 0, len2 = parts.length; r < len2; r++) {
            p1 = parts[r];
            if (!(p1 !== p0)) {
              continue;
            }
            isAfter = p1.start > p0.start;
            isEarly = p1.end < p0.end;
            if (isAfter * isEarly) {
              p0.children.push(p1);
              p1.parents.push(p0);
            }
          }
        }
        childs = parts.filter(function(p) {
          return p.parents.length;
        });
        childs.sort(function(a, b) {
          return a.text.length - b.text.length;
        });
        for (u = 0, len3 = childs.length; u < len3; u++) {
          adopted = childs[u];
          adopted.parents.sort(function(a, b) {
            return a.text.length - b.text.length;
          });
        }
        for (v = 0, len4 = childs.length; v < len4; v++) {
          p0 = childs[v];
          ref3 = p0.parents;
          for (w = 0, len5 = ref3.length; w < len5; w++) {
            parent = ref3[w];
            if (-1 === (i = items.findIndex(function(p1) {
              return p1.text === p0.text;
            }))) {
              ({start, end, length} = p0);
              item = {};
              if (p0.isString) {
                text = p0.text.substring(1, p0.text.length - 1);
                item.ref = OPTR.StringPointer.from(text);
                item.type = "text";
              }
              item.text = p0.text;
              item.type = item.type || "part";
              item.part = {start, end, length};
              i += items.push(item);
            }
            parent.text = parent.text.split(p0.text).join("$part" + i);
          }
        }
        p0text = parts[0].text;
        length = p0text.length - 2;
        result = p0text.substring(1, 1 + length);
        if (parts[0].children.length) {
          return repart(result);
        }
        return result;
      };
      partRawQuery = function() {
        var end, i1, iname, index, input, item, item0, item1, itext, label, len, len1, len2, len3, len4, len5, len6, len7, len8, len9, o, pquery, prev, q, qbinds, qpart, qparts, qregex, qtype, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, requery, rname, rtext, start, sub, subs, text, text0, text1, toref, type, u, v, value, w, x, y, z;
        rtext = repart(query);
        items.map(function(item, i) {
          return Object.assign(item, {
            text: item.text.substring(1, item.text.length - 1),
            name: `$part${i}`,
            item: new Object
          });
        });
        ref1 = items.filter(function(i) {
          return i.text.includes("$part");
        });
        for (o = 0, len = ref1.length; o < len; o++) {
          subs = ref1[o];
          ref2 = subs.text.split(/\s/g).filter(function(s) {
            return s.startsWith("$part");
          });
          for (q = 0, len1 = ref2.length; q < len1; q++) {
            sub = ref2[q];
            subs.item[sub] = items[sub.replace("$part", "")];
          }
        }
        requery = `${query}`;
        for (label in sources) {
          ref = sources[label];
          if (!requery.includes(label)) {
            continue;
          }
          if (items.find(function(i) {
            return i.ref === ref;
          })) {
            continue;
          }
          items.push({
            ref: ref,
            type: "ref",
            text: label,
            name: `$ref${items.length}`
          });
        }
        ref3 = items.filter(function(i) {
          return !i.ref;
        });
        for (r = 0, len2 = ref3.length; r < len2; r++) {
          item0 = ref3[r];
          ref4 = items.filter(function(i) {
            return i.ref;
          });
          for (u = 0, len3 = ref4.length; u < len3; u++) {
            item1 = ref4[u];
            text0 = item0.text;
            text1 = item1.text;
            if (!text0.includes(text1)) {
              continue;
            }
            if (text0 === text1) {
              item0.to = item1;
              continue;
            }
            item0.text = text0.split(text1).join(item1.name);
            item0.item[item1.name] = item1;
          }
        }
        ref5 = items.filter(function(i) {
          return i.to;
        });
        for (v = 0, len4 = ref5.length; v < len4; v++) {
          item0 = ref5[v];
          iname = item0.name;
          toref = item0.to;
          rname = toref.name;
          ref6 = items.filter(function(i) {
            return i.text.includes(iname);
          });
          for (w = 0, len5 = ref6.length; w < len5; w++) {
            item1 = ref6[w];
            item1.text = item1.text.split(iname).join(rname);
            item1.item[rname] = toref;
            delete item1.item[iname];
          }
          rtext = rtext.split(iname).join(rname);
        }
        items = items.filter(function(i) {
          return !i.to;
        });
        for (x = 0, len6 = items.length; x < len6; x++) {
          item = items[x];
          if (rtext.includes(itext = item.text)) {
            rtext = rtext.split(itext).join(item.name);
          }
        }
        pquery = ` ${rtext} `;
        qbinds = "select|from|where|order by|limit".split("|");
        qregex = new RegExp(` ${qbinds.join(" | ")} `, "gi");
        qparts = [];
        ref7 = pquery.matchAll(qregex);
        for (qpart of ref7) {
          [qtype] = qpart;
          ({
            index: start,
            input
          } = qpart);
          ({
            length: index
          } = qparts);
          text = input.substring(start);
          type = qtype.trim();
          end = start + text.length;
          qparts[index] = {type, text, start, end};
          if (prev = qparts[index - 1]) {
            prev.end = start;
            prev.text = qpart.input.substring(prev.start, start);
          }
        }
        for (y = 0, len7 = qparts.length; y < len7; y++) {
          qpart = qparts[y];
          ({type, text} = qpart);
          [start, end] = [0, 0];
          while (text.startsWith(" ")) {
            text = text.substring(1);
            ++start;
          }
          while (text.endsWith(" ")) {
            text = text.substring(0, text.length - 1);
            end--;
          }
          if (text.startsWith(type)) {
            text = text.substring(start += type.length);
          }
          qpart.text = text;
          qpart.start += start;
          qpart.end += end;
        }
        qparts.at(-0).start--;
        qparts.at(-1).end--;
        for (z = 0, len8 = qparts.length; z < len8; z++) {
          qpart = qparts[z];
          ({start, end, text, type} = qpart);
          index = items.length;
          iname = [
            "$",
            {
              from: "tables",
              where: "matches",
              select: "columns"
            }[type]
          ].join("");
          items[index] = {
            name: iname,
            text,
            type: "qpart",
            part: {start, end},
            item: {}
          };
          rtext = rtext.split(text).join(iname);
        }
        for (i1 = 0, len9 = items.length; i1 < len9; i1++) {
          value = items[i1];
          if (!Object.hasOwn(items, value.name)) {
            Object.defineProperty(items, value.name, {value});
          }
        }
        return rtext;
      };
      parseColumns = function() {
        var calias, cdef, coldefs, colref, coltext, cparse, i, iColumnsStart, index, j, l, len, len1, len2, len3, o, prev, q, r, ref, ref1, results1, start, text, u, value;
        coldefs = [];
        coltext = `,${items.$columns.text},`;
        ref1 = coltext.matchAll(/\,/g);
        for (cdef of ref1) {
          start = cdef.index + 1;
          index = coldefs.length;
          coldefs[index] = {start};
          if (prev = coldefs[index - 1]) {
            prev.end = start - 1;
          }
        }
        coldefs.splice(-1);
        for (o = 0, len = coldefs.length; o < len; o++) {
          cdef = coldefs[o];
          text = coltext.substring(cdef.start, cdef.end);
          l = text.length;
          i = 0;
          j = l - 1;
          while (!text[i].replace(",", "").trim()) {
            i++;
          }
          while (!text[j].replace(",", "").trim()) {
            j--;
          }
          cdef.text = text.substring(i, j + 1);
        }
        iColumnsStart = items.$columns.part.start;
        for (q = 0, len1 = coldefs.length; q < len1; q++) {
          cdef = coldefs[q];
          cdef.start += iColumnsStart;
          cdef.end = cdef.start + cdef.text.length - 1;
        }
        for (r = 0, len2 = coldefs.length; r < len2; r++) {
          cdef = coldefs[r];
          cparse = cdef.text.split(new RegExp(" as ", "i"));
          colref = cparse.at(0);
          calias = cparse.at(-1);
          if (!(ref = items[colref])) {
            throw /REFNOTFOUND/;
          }
          if (colref !== calias) {
            items.push(ref = {
              ref: ref.ref,
              text: calias,
              type: "alias",
              name: `$ref${items.length}`
            });
            items.$columns.text = items.$columns.text.split(cdef.text).join(ref.name);
          }
          cdef.ref = items.$columns.item[ref.name] = ref;
        }
        items.$columns.subs = coldefs;
        results1 = [];
        for (u = 0, len3 = items.length; u < len3; u++) {
          value = items[u];
          if (!Object.hasOwn(items, value.name)) {
            results1.push(Object.defineProperty(items, value.name, {value}));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      };
      parseSources = function() {
        var i, index, j, l, len, len1, len2, len3, o, prev, q, r, ref, ref1, results1, start, talias, tbldefs, tblref, tbltext, tdef, text, tparse, u, value;
        tbldefs = [];
        tbltext = `,${items.$tables.text},`;
        ref1 = tbltext.matchAll(/\,/g);
        for (tdef of ref1) {
          start = tdef.index + 1;
          index = tbldefs.length;
          tbldefs[index] = {start};
          if (prev = tbldefs[index - 1]) {
            prev.end = start - 1;
          }
        }
        tbldefs.splice(-1);
        for (o = 0, len = tbldefs.length; o < len; o++) {
          tdef = tbldefs[o];
          text = tbltext.substring(tdef.start, tdef.end);
          l = text.length;
          i = 0;
          j = l - 1;
          while (!text[i].replace(",", "").trim()) {
            i++;
          }
          while (!text[j].replace(",", "").trim()) {
            j--;
          }
          tdef.text = text.substring(i, j + 1);
        }
        for (q = 0, len1 = tbldefs.length; q < len1; q++) {
          tdef = tbldefs[q];
          tdef.start += items.$tables.part.start;
          tdef.end = tdef.start + tdef.text.length - 1;
        }
        for (r = 0, len2 = tbldefs.length; r < len2; r++) {
          tdef = tbldefs[r];
          tparse = tdef.text.split(new RegExp(" ", "i"));
          tblref = tparse.at(0);
          talias = tparse.at(-1);
          if (!(ref = items[tblref])) {
            throw /REFNOTFOUND/;
          }
          if (tblref !== talias) {
            items.push(ref = {
              ref: ref.ref,
              text: talias,
              type: "alias",
              name: `$ref${items.length}`
            });
            items.$tables.text = items.$tables.text.split(tdef.text).join(ref.name);
          }
          tdef.ref = items.$tables.item[ref.name] = ref;
        }
        items.$tables.subs = tbldefs;
        results1 = [];
        for (u = 0, len3 = items.length; u < len3; u++) {
          value = items[u];
          if (!Object.hasOwn(items, value.name)) {
            results1.push(Object.defineProperty(items, value.name, {value}));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      };
      parseMatches = function() {
        var bound, i, index, j, l, len, len1, len2, len3, len4, mamdefs, matref, mattext, mdef, o, prev, q, r, ref, ref1, ref2, results1, start, t, text, u, v, value;
        mamdefs = [];
        mattext = ` and ${items.$matches.text} and `;
        ref1 = mattext.matchAll(new RegExp(" and | or ", "gi"));
        for (mdef of ref1) {
          start = mdef.index + mdef[0].length;
          index = mamdefs.length;
          bound = mdef[0].trim();
          mamdefs[index] = {start, bound};
          if (prev = mamdefs[index - 1]) {
            prev.end = mdef.index;
          }
        }
        mamdefs.splice(-1);
        delete mamdefs[0].bound;
        for (o = 0, len = mamdefs.length; o < len; o++) {
          mdef = mamdefs[o];
          text = mattext.substring(mdef.start, mdef.end);
          l = text.length;
          i = 0;
          j = l - 1;
          while (!text[i].trim()) {
            i++;
          }
          while (!text[j].trim()) {
            j--;
          }
          mdef.text = text.substring(i, j + 1);
        }
        for (q = 0, len1 = mamdefs.length; q < len1; q++) {
          mdef = mamdefs[q];
          mdef.start += items.$matches.part.start;
          mdef.end = mdef.start + mdef.text.length - 1;
        }
        for (i = r = 0, len2 = mamdefs.length; r < len2; i = ++r) {
          mdef = mamdefs[i];
          if (!(i > 0)) {
            continue;
          }
          mamdefs[i].required = true;
          mamdefs[i - 1].required = mdef.bound !== "or";
        }
        for (u = 0, len3 = mamdefs.length; u < len3; u++) {
          mdef = mamdefs[u];
          matref = mdef.text;
          if (!(ref = items[matref])) {
            throw /REFNOTFOUND/;
          }
          items.$matches.item[ref.name] = mdef.ref = ref;
          ref2 = ref.item;
          for (t in ref2) {
            i = ref2[t];
            if (i.type !== "part") {
              continue;
            }
            i.required = mdef.required;
          }
          ref.required = mdef.required;
          delete mdef.required;
        }
        items.$matches.subs = mamdefs;
        results1 = [];
        for (v = 0, len4 = items.length; v < len4; v++) {
          value = items[v];
          if (!Object.hasOwn(items, value.name)) {
            results1.push(Object.defineProperty(items, value.name, {value}));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      };
      resolveParts = function() {
        var arg, arg0, arg1, i, len, len1, nname, numi, o, op, part, q, ref, ref1, subs, text, val;
        for (o = 0, len = items.length; o < len; o++) {
          part = items[o];
          if (!(part.type === "part")) {
            continue;
          }
          text = part.text;
          subs = text.split(/\s+/g);
          arg0 = subs.at(+0);
          arg1 = subs.at(-1);
          op = part.text.substring(arg0.length, text.length - arg1.length).trim().replace(/is not|not|\<\>/gi, "!=").replace(/is/gi, "=").replace(/and/gi, "&&").replace(/or/gi, "||");
          ref1 = [arg0, arg1];
          for (i = q = 0, len1 = ref1.length; q < len1; i = ++q) {
            arg = ref1[i];
            if (arg.startsWith("$")) {
              if (!(ref = part.item[arg] = items[arg])) {
                throw /ARGNTFOUND/;
              }
            } else if (!isNaN(val = Number(arg))) {
              numi = items.length;
              nname = `$num${numi}`;
              ref = {
                ref: OPTR.NumberPointer.from(val),
                type: "number",
                name: nname
              };
              part.item[nname] = items[numi] = ref;
            }
            if (i === 0) {
              arg0 = ref;
            }
            if (i === 1) {
              arg1 = ref;
            }
          }
          part.text = [arg0.name, op, arg1.name].join(" ");
          part.operate = [arg0.ref || arg0, op, arg1.ref || arg1];
        }
        return 0;
      };
      rquery = partRawQuery();
      parseColumns();
      parseSources();
      parseMatches();
      resolveParts();
      table(items);
      warn(query);
      return warn(rquery);
    }

    parse3(query = "") {
      var bypass, filter, i, i1, index, item, item0, item1, items, j, j1, k, k1, l1, label, len, len1, len10, len11, len12, len13, len14, len15, len16, len2, len3, len4, len5, len6, len7, len8, len9, length, m, m1, match, matchs, mtext, n1, next, o, o1, opener, openers, otext, parent, prevText, q, q1, qpart, qparts, r, ref, ref1, ref2, ref3, ref4, ref5, sources, split, start, t, text, u, v, value, w, x, y, z;
      log(query = query.trim());
      items = [{}];
      sources = this.getSourceRefs();
      for (label in sources) {
        ref = sources[label];
        split = query.split(label);
        if (split.length > 1) {
          if (-1 === (i = items.findIndex(function(f) {
            return f.label === label;
          }))) {
            i += items.push({
              ref,
              label,
              type: "src"
            });
          }
          query = split.join(`$s${i}`);
        } else {
          query = split.join(" ");
        }
      }
      qparts = [];
      ref1 = query.matchAll(/([(\d+)]+[(\.)|(\d)]+[\d+])|(\d)/g);
      for (match of ref1) {
        value = match[0] * 1;
        index = match.index;
        length = match[0].length;
        if (query[index - 3] === "$") {
          continue;
        }
        if (query[index - 2] === "$") {
          continue;
        }
        if (query[index - 1] === "$") {
          continue;
        }
        if (query[index - 1] === "-") {
          index -= 1;
          length += 1;
          value *= -1;
        }
        if (-1 === (i = items.findIndex(function(f) {
          return f.value === value;
        }))) {
          ref = OPTR.NumberPointer.from(value);
          i += items.push({ref, value});
        }
        qparts.push({
          start: index,
          end: index + length,
          text: `$n${i}`,
          real: match[0]
        });
      }
      index = 0;
      for (i = o = 0, len = qparts.length; o < len; i = ++o) {
        qpart = qparts[i];
        qpart.prev = query.substring(index, qpart.start);
        index = qpart.end;
        if (next = qparts[i + 1]) {
          qpart.next = query.substring(index, next.start);
        } else {
          qpart.next = query.substring(index);
        }
      }
      query = qparts[0].prev;
      for (i = q = 0, len1 = qparts.length; q < len1; i = ++q) {
        qpart = qparts[i];
        query = query.trim() + ` ${qpart.text} ` + qpart.next;
      }
      query = query;
      qparts = [];
      ref2 = query.matchAll(Comparision.matchRegExp);
      for (match of ref2) {
        value = match[0].trim();
        index = match.index;
        length = match[0].length;
        if (-1 === (i = items.findIndex(function(f) {
          return f.cmd === value;
        }))) {
          ref = Comparision.from(value);
          i += items.push({
            ref,
            cmd: value
          });
        }
        qparts.push({
          start: index,
          end: index + length,
          text: `$c${i}`,
          real: match[0]
        });
      }
      index = 0;
      for (i = r = 0, len2 = qparts.length; r < len2; i = ++r) {
        qpart = qparts[i];
        qpart.prev = query.substring(index, qpart.start);
        index = qpart.end;
        if (next = qparts[i + 1]) {
          qpart.next = query.substring(index, next.start);
        } else {
          qpart.next = query.substring(index);
        }
      }
      query = qparts[0].prev;
      for (i = u = 0, len3 = qparts.length; u < len3; i = ++u) {
        qpart = qparts[i];
        query = query.trim() + ` ${qpart.text} ` + qpart.next;
      }
      qparts = [];
      ref3 = query.matchAll(Mathematics.matchRegExp);
      for (match of ref3) {
        value = match[0];
        index = match.index;
        length = match[0].length;
        if (-1 === (i = items.findIndex(function(f) {
          return f.op === value;
        }))) {
          ref = Mathematics.from(value);
          i += items.push({
            ref,
            op: value
          });
        }
        qparts.push({
          start: index,
          end: index + length,
          text: `$m${i}`,
          real: match[0]
        });
      }
      index = 0;
      for (i = v = 0, len4 = qparts.length; v < len4; i = ++v) {
        qpart = qparts[i];
        qpart.prev = query.substring(index, qpart.start);
        index = qpart.end;
        if (next = qparts[i + 1]) {
          qpart.next = query.substring(index, next.start);
        } else {
          qpart.next = query.substring(index);
        }
      }
      query = qparts[0].prev;
      for (i = w = 0, len5 = qparts.length; w < len5; i = ++w) {
        qpart = qparts[i];
        query = query.trim() + ` ${qpart.text} ` + qpart.next;
      }
      qparts = [];
      ref4 = query.matchAll(/\ and |\ or /gi);
      for (match of ref4) {
        value = match[0].trim();
        index = match.index;
        length = match[0].length;
        if (-1 === (i = items.findIndex(function(f) {
          return f.rule === value;
        }))) {
          ref = value;
          i += items.push({
            ref,
            rule: value
          });
        }
        qparts.push({
          start: index,
          end: index + length,
          text: `$b${i}`,
          real: match[0]
        });
      }
      index = 0;
      for (i = x = 0, len6 = qparts.length; x < len6; i = ++x) {
        qpart = qparts[i];
        qpart.prev = query.substring(index, qpart.start);
        index = qpart.end;
        if (next = qparts[i + 1]) {
          qpart.next = query.substring(index, next.start);
        } else {
          qpart.next = query.substring(index);
        }
      }
      query = qparts[0].prev;
      for (i = y = 0, len7 = qparts.length; y < len7; i = ++y) {
        qpart = qparts[i];
        query = query.trim() + ` ${qpart.text} ` + qpart.next;
      }
      query = query.replace(/\s+/g, " ");
      query = query.replace(/\s+\)/g, ")");
      openers = Object.fromEntries("() [] {}".split(" ").map((a) => {
        return a.split("").reverse();
      }));
      matchs = [];
      ref5 = query.matchAll(/\(|\)|\[|\]|\{|\}|\`|\'|\"/g);
      for (match of ref5) {
        text = match[0];
        filter = matchs.filter(function(m) {
          return m.text === text;
        });
        index = filter.length;
        start = match.index + 1;
        matchs.push({
          text,
          index,
          start,
          children: []
        });
      }
      bypass = Object.values(openers);
      for (z = 0, len8 = matchs.length; z < len8; z++) {
        match = matchs[z];
        mtext = match.text;
        otext = openers[mtext] || mtext;
        if (bypass.includes(mtext)) {
          continue;
        }
        if (openers[mtext] || match.index % 2) {
          opener = matchs.findLast(function(n) {
            return (n.text === otext) && !n.end && (n.start < match.start);
          });
          opener.end = match.start - 1;
          opener.strlen = opener.end - opener.start;
          opener.substring = query.substring(opener.start, opener.end);
          opener.bound = mtext;
          match.closed = true;
        }
      }
      matchs = matchs.filter(function(m) {
        return !m.closed;
      }).sort(function(a, b) {
        return a.strlen - b.strlen;
      });
      for (i = i1 = 0, len9 = matchs.length; i1 < len9; i = ++i1) {
        m = matchs[i];
        if (!openers[m.bound]) {
          continue;
        }
        parent = matchs.filter(function(n) {
          return n.end > m.end;
        }).filter(function(n) {
          return n.start < m.start;
        }).filter(function(n) {
          return n.strlen > m.strlen;
        }).at(0);
        if (!parent) {
          continue;
        }
        parent.children.push(m);
      }
      for (j1 = 0, len10 = matchs.length; j1 < len10; j1++) {
        m = matchs[j1];
        m.text = m.substring;
        Reflect.deleteProperty(m, "index");
        Reflect.deleteProperty(m, "strlen");
        Reflect.deleteProperty(m, "substring");
        Reflect.deleteProperty(m, "bound");
      }
      for (k1 = 0, len11 = matchs.length; k1 < len11; k1++) {
        m = matchs[k1];
        m.items || (m.items = {});
        item = m.text.split(/\(|\)|\[|\]|\{|\}|\`|\'|\"|\s/g);
        item = item.filter(function(t) {
          return t.startsWith("$");
        });
        for (l1 = 0, len12 = item.length; l1 < len12; l1++) {
          i = item[l1];
          index = i.split(/[^\d]/g).filter(Number).at(-1);
          m.items[i] = items[index];
        }
      }
      for (m1 = 0, len13 = matchs.length; m1 < len13; m1++) {
        m = matchs[m1];
        if (-1 === (i = items.findIndex(function(t) {
          return t.ref === m;
        }))) {
          i += items.push({
            ref: m,
            type: "part"
          });
        }
        query = query.split(m.text).join(m.part = `$part${i}`);
      }
      for (i = n1 = 0, len14 = items.length; n1 < len14; i = ++n1) {
        item0 = items[i];
        if (item0.type !== "part") {
          continue;
        }
        for (j = o1 = 0, len15 = items.length; o1 < len15; j = ++o1) {
          item1 = items[j];
          if (item1.type !== "part") {
            continue;
          }
          if (!(j - i)) {
            continue;
          }
          prevText = item1.ref.text;
          item1.ref.text = prevText.split(item0.ref.text).join(t = `$part${i}`);
          query = query.replace(prevText, t);
        }
      }
      for (k = q1 = 0, len16 = matchs.length; q1 < len16; k = ++q1) {
        m = matchs[k];
        for (item in m.items) {
          if (m.text.includes(item)) {
            continue;
          }
          delete m.items[item];
        }
      }
      warn(matchs);
      warn(query);
      return warn(items);
    }

    parse2(query = "") {
      var alsi, alss, cAlias, colPath, coln, colpart, compart, compartindex, cpName, cparse, cpart, dbName, dbpart, domparts, end, i, i1, iName, index, isInteger, isNegative, item, j, j1, k1, len, len1, len10, len11, len2, len3, len4, len5, len6, len7, len8, len9, match, num, numi, nums, o, parent, part, parts, prev, q, r, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, refrules, resolverule, rule, s, src, srcName, srcTable, srccol, srcpart, start, str, stri, strs, t, tAlias, tables, targets, tbl, tblName, tblpart, text, tn, triml, typedNumber, u, v, value, w, x, y, z;
      nums = [];
      item = [];
      prev = 0;
      ref1 = query.matchAll(Database.regExp.numbersplit);
      for (part of ref1) {
        index = part.index;
        if (!prev) {
          prev = index;
          continue;
        }
        text = query.substring(prev, index);
        if (!isNaN(text) && text.match(/\d/)) {
          value = text * 1;
          isInteger = Number.isInteger(value);
          isNegative = value < 0;
          typedNumber = (function() {
            if (!value) {
              return "Uint8";
            } else if (!isInteger) {
              switch (10 < text.indexOf(".")) {
                case true:
                  return "Float64";
                case false:
                  return "Float32";
              }
            } else if (!isNegative) {
              switch (true) {
                case value <= 0xff:
                  return "Uint8";
                case value <= 0xffff:
                  return "Uint16";
                case value <= 0xffffffff:
                  return "Uint32";
                default:
                  return "BigUint64";
              }
            } else {
              switch (true) {
                case Math.abs(value) <= 0xff / 2 - 1:
                  return "Int8";
                case Math.abs(value) <= 0xffff / 2 - 1:
                  return "Int16";
                case Math.abs(value) <= 0xffffffff / 2 - 1:
                  return "Int32";
                default:
                  return "BigInt64";
              }
            }
          })();
          nums.push({
            start: prev,
            end: index,
            type: typedNumber,
            value
          });
        }
        prev = index + 1;
      }
      ref2 = nums.reverse();
      for (o = 0, len = ref2.length; o < len; o++) {
        num = ref2[o];
        numi = item.findIndex(function(i) {
          return 0 === (i.value - num);
        });
        if (-1 === numi) {
          query = [query.substring(0, num.start), "$", item.push(num) - 1, query.substring(num.end)].join("");
        } else {
          query = [query.substring(0, num.start), "$", numi, query.substring(num.end)].join("");
        }
      }
      for (q = 0, len1 = nums.length; q < len1; q++) {
        num = nums[q];
        num.ref = OPTR[num.type + "Number"].from(num.value);
      }
      prev = 0;
      strs = [];
      stri = 0;
      ref3 = query.matchAll(Database.regExp.textpart);
      for (part of ref3) {
        index = part.index;
        stri = stri + 1;
        if (!prev) {
          prev = index + 1;
          continue;
        }
        if (!(stri % 2)) {
          text = query.substring(prev, index);
          strs.push({
            start: prev - 1,
            end: index + 1,
            value: text,
            type: "string"
          });
        }
        prev = index + 1;
      }
      ref4 = strs.reverse();
      for (r = 0, len2 = ref4.length; r < len2; r++) {
        str = ref4[r];
        query = [query.substring(0, str.start), "$", item.push(str) - 1, query.substring(str.end)].join("");
      }
      prev = 0;
      alss = [];
      alsi = 0;
      ref5 = query.matchAll(Database.regExp.aliasparser);
      for (part of ref5) {
        index = part.index;
        alsi = alsi + 1;
        if (!prev) {
          prev = index + 4;
          continue;
        }
        if (!(alsi % 2)) {
          text = query.substring(prev, index).split(/\s+|\,/).at(0);
          alss.push({
            start: prev,
            end: prev + text.length,
            value: text,
            type: "alias"
          });
        }
        prev = index + 4;
      }
      if (part.index) {
        text = query.substring(prev).split(/\s+|\,/).at(0);
        alss.push({
          start: prev,
          end: prev + text.length,
          value: text,
          type: "alias"
        });
      }
      ref6 = alss.reverse();
      for (u = 0, len3 = ref6.length; u < len3; u++) {
        str = ref6[u];
        if (-1 === (i = item.findIndex(function(a) {
          return (a.value === str.value) && a.type === "alias";
        }))) {
          i += item.push(str);
        }
      }
      parts = [];
      ref7 = query.matchAll(Database.regExp.partparser);
      for (match of ref7) {
        if (match[0].match(Database.regExp.partopener)) {
          start = match.index + match[0].length;
          triml = 0;
          while (!query[start].trim()) {
            start++;
          }
          parts.push({start});
        } else {
          part = parts.findLast(function(p) {
            return p.start && !p.end;
          });
          end = match.index - match[0].length;
          while (!query[end].match(Database.regExp.partparser) && !query[end].trim()) {
            end--;
          }
          part.end = end + 1;
          part.length = part.end - part.start;
        }
      }
      for (v = 0, len4 = parts.length; v < len4; v++) {
        part = parts[v];
        Object.defineProperties(part, {
          children: {
            value: []
          },
          parents: {
            value: []
          }
        });
      }
      parts.map(function(p0, i) {
        var c, p1;
        c = [];
        while ((p1 = parts[i++])) {
          if (p1.start > p0.start) {
            if (!(p1.end < p0.end)) {
              continue;
            }
            (c[c.length] = p1).parents.push(p0);
          }
        }
        if (c.length) {
          p0.children.push(...c);
        }
        return p0;
      }).map(function(p) {
        text = query.substring(p.start, p.end);
        return Object.assign(p, {text});
      });
      item.push.apply(item, parts.sort(function(a, b) {
        if (a.length < b.length) {
          return -2;
        } else if (a.children.length < b.children.length) {
          return -1;
        } else {
          return 1;
        }
      }).map(function({text, start, end}) {
        return {
          type: "part",
          value: text,
          start,
          end
        };
      }));
      dbName = this.name.toPrimitive();
      targets = [];
      colpart = "";
      srcpart = "";
      compart = "";
      compartindex = 0;
      ref8 = query.matchAll(Database.regExp.querypart);
      for (part of ref8) {
        switch (part[0].trim()) {
          case "from":
            srcpart = query.substring(part.index + part[0].length);
            break;
          case "where":
            compart = query.substring(part[0].length + (compartindex = part.index));
            break;
          case "select":
            colpart = query.substring(part.index + part[0].length);
            break;
          default:
            throw /UNDEFINED_PARTERR/;
        }
      }
      tables = {};
      colpart = colpart.substring(0, colpart.lastIndexOf("from")).split(/\,/g).map(function(p) {
        return p.trim();
      });
      srcpart = srcpart.substring(0, Math.max(srcpart.lastIndexOf("where"), srcpart.length)).split(/\,/g).map(function(p) {
        return p.trim();
      });
      for (w = 0, len5 = srcpart.length; w < len5; w++) {
        src = srcpart[w];
        [tblName, tAlias] = src.split(/\s+|as/gi).filter(Boolean);
        srcName = tAlias || tblName;
        srcTable = this.find(function(t) {
          return t.name.eq(tblName);
        });
        tables[srcName] = srcTable;
      }
      for (x = 0, len6 = colpart.length; x < len6; x++) {
        coln = colpart[x];
        if (!coln.startsWith("$")) {
          cparse = coln.trim().split(/\s+| as |\`/gi).filter(Boolean);
          cpName = cparse.at(0);
          colPath = cpName.split(this.constructor.regExp.perdefineds).filter(Boolean).at(0).split(this.constructor.regExp.partparser).filter(Boolean).at(0);
          domparts = colPath.split(".").reverse();
          [cpart, tblpart, dbpart] = [...domparts];
          if (cparse.length > 1) {
            cAlias = cparse.at(-1);
          } else {
            cAlias = cpart;
          }
          if (dbpart) {
            throw /DBPARTIN_COLDEF/;
            srccol = void 0;
          } else if ((tAlias = tblpart)) {
            tbl = tables[tblpart] || this.find(function(t) {
              return t.name.eq(tblpart);
            });
            srccol = tbl.find(function(c) {
              return c.name.eq(cpart);
            });
          } else {
            for (tn in tables) {
              t = tables[tn];
              if (srccol = t.find(function(c) {
                return c.name.eq(cpart);
              })) {
                break;
              }
            }
          }
          if (!tAlias) {
            for (tn in tables) {
              t = tables[tn];
              if (!t.includes(srccol)) {
                continue;
              }
              tAlias = tn;
              break;
            }
          }
          targets.push({
            cAlias: cAlias,
            tAlias: tAlias,
            column: srccol
          });
        } else {
          cparse = coln.trim().split(/\s+| as |\`/gi).filter(Boolean);
          iName = cparse.at(0);
          if (cparse.length > 1) {
            cAlias = cparse.at(-1);
          } else {
            cAlias = iName;
          }
          targets.push({
            cAlias: cAlias,
            column: cparse[0],
            ref: item[cparse[0].substring(1)]
          });
        }
      }
      resolverule = function(rule) {
        var c, len7, next, nextindex, nextitem, op, prevEnd, previndex, previtem, ref10, ref9, rindex, rulesolv, solved, y;
        ref9 = rule.children;
        for (y = 0, len7 = ref9.length; y < len7; y++) {
          c = ref9[y];
          resolverule(c);
        }
        if (!rule.solved && (rule.solved = [])) {
          previndex = 0;
          ref10 = rule.text.matchAll(Database.regExp.comparser);
          for (op of ref10) {
            nextindex = op.index + op[0].length;
            while (!rule.text[nextindex].trim()) {
              nextindex++;
            }
            prevEnd = op.index - 1;
            while (!rule.text[prevEnd].trim()) {
              prevEnd--;
            }
            prevEnd++;
            rindex = -1 + rule.solved.push(rulesolv = {
              prev: prev = rule.text.substring(previndex, prevEnd),
              next: next = rule.text.substring(nextindex),
              op: op[0].trim(),
              index: previndex,
              end: prevEnd,
              nextindex: nextindex,
              rule
            });
            previtem = null;
            nextitem = null;
            for (tn in tables) {
              t = tables[tn];
              if (c = t.getColumn(prev)) {
                if (!item.find(function(i) {
                  return (i.type === "column") && (i.value === prev);
                })) {
                  item.push(previtem = {
                    type: "column",
                    value: prev,
                    ref: c
                  });
                }
                continue;
              }
              if (c = t.getColumn(next)) {
                if (!item.find(function(i) {
                  return (i.type === "column") && (i.value === next);
                })) {
                  item.push(nextitem = {
                    type: "column",
                    value: next,
                    ref: c
                  });
                }
                continue;
              }
            }
            if (!item.find(function(i) {
              return i.value === prev;
            })) {
              if (c = targets.find(function(i) {
                return (i.cAlias === prev) || (i.column === prev);
              })) {
                item.push(previtem = {
                  type: "column",
                  value: prev,
                  ref: c
                });
              }
            }
            if (!item.find(function(i) {
              return i.value === next;
            })) {
              if (c = targets.find(function(i) {
                return (i.cAlias === next) || (i.column === next);
              })) {
                item.push(nextitem = {
                  type: "column",
                  value: next,
                  ref: c
                });
              }
            }
            if (rindex) {
              solved = rule.solved[rindex - 1];
              solved.next = rule.text.substring(solved.nextindex, prevEnd);
              rule.solved[rindex].prev = rule.solved[rindex - 1];
            }
            previndex = op.index + op[0].length;
            while (!rule.text[previndex].trim()) {
              previndex++;
            }
          }
        }
        return 0;
      };
      for (j = y = 0, len7 = parts.length; y < len7; j = ++y) {
        rule = parts[j];
        resolverule(rule);
      }
      for (j = z = 0, len8 = parts.length; z < len8; j = ++z) {
        rule = parts[j];
        if (!(rule.solved.length === 1)) {
          continue;
        }
        rule.prev = rule.solved[0].prev;
        rule.next = rule.solved[0].next;
        rule.op = rule.solved[0].op;
        rule.alias = "$" + item.length;
        item[item.length] = {
          type: "rule",
          value: rule.alias,
          rule
        };
        ref9 = rule.parents;
        for (i1 = 0, len9 = ref9.length; i1 < len9; i1++) {
          parent = ref9[i1];
          parent.text = parent.text.split(rule.text).join(rule.alias);
        }
      }
      refrules = function(rule) {
        var n, next, p, ref;
        if (prev = rule.prev) {
          if (prev[0] === "$") {
            rule.prev = item[prev.substring(1)];
          } else if (p = item.find(function(i) {
            return i.value === prev;
          })) {
            rule.prev = p;
          }
          if (rule.prev && (ref = rule.prev.ref)) {
            rule.prev = ref;
          }
        }
        if (next = rule.next) {
          if (next[0] === "$") {
            rule.next = item[next.substring(1)];
          } else if (n = item.find(function(i) {
            return i.value === next;
          })) {
            rule.next = n;
          }
          if (rule.next && (ref = rule.next.ref)) {
            rule.next = ref;
          }
        }
        return 0;
      };
      for (j1 = 0, len10 = parts.length; j1 < len10; j1++) {
        part = parts[j1];
        refrules(part);
        ref10 = part.solved;
        for (k1 = 0, len11 = ref10.length; k1 < len11; k1++) {
          s = ref10[k1];
          refrules(s);
        }
        0;
      }
      table(item);
      error("\n\n", query);
      error("\n\n", item);
      error("\n\n", parts.at(-1).text);
      warn("\n\n", parts.filter(function(p) {
        return p.solved.length === 1;
      }));
      return 1;
    }

  };

  Database.classPointer = OPTR.ClassPointer.from(Database);

  Database.prototype.regExp = /select | from | where | as | and | or |\.|\,|\'|\"|\(|\)|SUM\(|AVG\(|MAX\(|MIN\(|\+|\-|\/|\*|\%|\=|\>|\<|\!/gi;

  Database.regExp = {
    querybinder: /union /gi,
    queryType: /select | from | where | group by | order by | limit/gi,
    tablebinder: /left join|right join|join/gi,
    pathbinder: /\./gi,
    textpart: /\'|\"/g,
    pathpart: /\`/g,
    aliasparser: / as /gi,
    rulebinder: / or | and /gi,
    nameparser: /\,/,
    comparision: /\=|\!\=|\<|\>|\>\=|\<\=/g,
    mathbinder: /\+|\-|\/|\*|\%/g,
    comparser: /\+|\-|\/|\*|\%|\=|\!\=|\<\=|\>\=|\>|\<| and | or | is not | is | not /gi,
    perdefineds: /SUM\(|AVG\(|MAX\(|MIN\(/gi,
    partparser: /\(|\)|\[|\]|\{|\}/g,
    partopener: /\(|\[|\{/g,
    numbersplit: /\s+|\(|\)|\[|\]|\{|\}|\,/g
  };

  return Database;

}).call(this);

export var Column = (function() {
  class Column extends OPTR.ObjectPointer {
    static from(options = {}) {
      var key, ptrc, ptri, val;
      ptri = this.new();
      ptrc = this.classPointer;
      for (key in options) {
        val = options[key];
        ptri[key] = ptrc.getProperty(key).from(val);
      }
      return ptri;
    }

    getProperty() {
      return this.instanceOf.getProperty(...arguments);
    }

  };

  Column.classPointer = OPTR.ClassPointer.from(Column);

  return Column;

}).call(this);

export var Row = class Row extends Object {};

export var Rule = class Rule extends OPTR.ObjectPointer {};

export var RuleSet = class RuleSet extends OPTR.ObjectPointer {};

export var Table = (function() {
  class Table extends OPTR.ObjectPointer {
    createColumn(name, instanceOf, byteLength) {
      return this.appendChild(Column.from({
        name,
        instanceOf,
        byteLength,
        offset: this.addStride(4)
      }));
    }

    addStride(byteLength = 0) {
      var offset;
      this.stride = byteLength + (offset = this.stride.toPrimitive());
      return offset;
    }

    getColumn(any) {
      if (!isNaN(any)) {
        return this.children[i];
      }
      return this.find(function(c) {
        return c.name.eq(any);
      });
    }

    get(index = 0) {
      var alias, basedv, byteLength, byteOffset, col, len, o, offset, ref1, result;
      byteLength = this.stride.toPrimitive();
      byteOffset = byteLength * index;
      basedv = this.base.dataView(byteOffset, byteLength);
      Object.defineProperties(result = new Row, {
        index: {
          value: index
        },
        byteOffset: {
          value: byteOffset
        },
        byteLength: {
          value: byteLength
        }
      });
      ref1 = this.children;
      for (o = 0, len = ref1.length; o < len; o++) {
        col = ref1[o];
        alias = col.instanceOf.getProperty("alias");
        offset = col.offset.toPrimitive();
        result[col.name.toPrimitive()] = basedv.get(alias, offset);
      }
      return result;
    }

    subdataview(byteOffset = 0, byteLength) {
      byteLength || (byteLength = this.byteLength - byteOffset);
      return this.base.dataView(byteOffset, byteLength);
    }

    subbuffer(byteOffset = 0, byteLength) {
      byteLength || (byteLength = this.byteLength - byteOffset);
      return this.base.subarray(byteOffset, byteLength).slice().buffer;
    }

    subarray(byteOffset = 0, byteLength) {
      byteLength || (byteLength = this.byteLength - byteOffset);
      return this.base.subarray(byteOffset, byteLength);
    }

    insert(values = {}) {
      var alias, basedv, col, key, len, o, offset, ref1, stride, value;
      stride = this.stride.toPrimitive();
      offset = this.offset.add(stride);
      basedv = this.base.dataView(offset, stride);
      ref1 = Object.keys(values);
      for (o = 0, len = ref1.length; o < len; o++) {
        key = ref1[o];
        col = this.getColumn(key);
        value = values[key];
        alias = col.instanceOf.getProperty("alias");
        basedv.set(alias, col.offset.toPrimitive(), value);
      }
      return offset / stride;
    }

  };

  Table.classPointer = OPTR.ClassPointer.from(Table);

  Object.defineProperty(Table.prototype, "byteLength", {
    get: function() {
      return this.pages.toPrimitive() * 654;
    }
  });

  Object.defineProperty(Table.prototype, "count", {
    get: function() {
      return this.offset.toPrimitive() / this.stride.toPrimitive();
    }
  });

  return Table;

}).call(this);

export var TypedAny = (function() {
  class TypedAny extends OPTR.ObjectPointer {
    static from(any, replaceWith = this.replaceWith) {
      var replace, rexp, rl, search, test, type, typeArray, typeCount;
      if (rl = replaceWith.length) {
        while (rl) {
          replace = replaceWith[--rl];
          search = replaceWith[--rl];
          any = any.replace(search, replace);
        }
      }
      if (!any.match(this.matchRegExp)) {
        throw /NONMATCHED_REXP/;
      }
      typeArray = this.definitions;
      typeCount = typeArray.length;
      while (type = --typeCount) {
        test = `\\${typeArray[type]}`;
        rexp = new RegExp(test, "gi");
        if (rexp.test(any)) {
          break;
        }
      }
      if (!type) {
        throw /TESTFAIL_ANY/;
      }
      return Object.assign(this.new(), {type});
    }

    static fromMatch(any) {
      if (0 < this.definitions.indexOf(any.toUpperCase())) {
        return this.from(any);
      }
      return void 0;
    }

    toPrimitive() {
      return this.constructor.definitions[this.type];
    }

  };

  TypedAny.classPointer = OPTR.ClassPointer.from(TypedAny);

  TypedAny.definitions = [0/0];

  TypedAny.replaceWith = [];

  TypedAny.matchRegExp = /$/gui;

  Object.defineProperty(TypedAny.prototype, "children", {
    enumerable: false,
    value: []
  });

  Object.defineProperty(TypedAny.prototype, "valueKey", {
    enumerable: true,
    get: function() {
      return this.toPrimitive();
    }
  });

  return TypedAny;

}).call(this);

export var Mathematics = (function() {
  class Mathematics extends TypedAny {};

  Mathematics.classPointer = OPTR.ClassPointer.from(Mathematics);

  Mathematics.matchRegExp = /\+\+|\-\-|\*\*|\/\/|\+|\-|\*|\//g;

  Mathematics.definitions = [0/0, "+", "-", "*", "/", "%", "++", "--", "**", "//"];

  return Mathematics;

}).call(this);

export var Comparision = (function() {
  class Comparision extends TypedAny {};

  Comparision.classPointer = OPTR.ClassPointer.from(Comparision);

  Comparision.matchRegExp = /\ is not |\ not |\ is |\>\=|\<\=|\=\=|\!\=|\>|\<|\=/gi;

  Comparision.replaceWith = [/is not/gi, "!=", /not/gi, "!=", /is/gi, "==", /\s/g, ""];

  Comparision.definitions = [0/0, ">=", "<=", "!=", "==", "<>", "<", ">", "=", "is not", "is", "not"];

  return Comparision;

}).call(this);

export var Operator = (function() {
  class Operator extends TypedAny {};

  Operator.classPointer = OPTR.ClassPointer.from(Operator);

  Operator.definitions = [0/0, "+", "-", "*", "/", "%"];

  return Operator;

}).call(this);

export var Operation = (function() {
  class Operation extends OPTR.ObjectPointer {
    static from(args = {}) {
      var begin, count, firstIndexIn0, firstIndexIn1, firstIndexOut, in0, in1, index, operation, operator, out, setByteOffsetIn0, setByteOffsetIn1, setByteOffsetOut, strideByteLengthIn0, strideByteLengthIn1, strideByteLengthOut;
      ({in0, in1, out, operator, begin = 0, count = 0, index = 0} = args);
      setByteOffsetIn0 = args.setByteOffsetIn0 || in0.offset.toPrimitive();
      firstIndexIn0 = args.firstIndexIn0 || 0;
      strideByteLengthIn0 = args.strideByteLengthIn0 || in0.parent.stride.toPrimitive();
      setByteOffsetIn1 = args.setByteOffsetIn1 || in1.offset.toPrimitive();
      firstIndexIn1 = args.firstIndexIn1 || 0;
      strideByteLengthIn1 = args.strideByteLengthIn1 || in1.parent.stride.toPrimitive();
      setByteOffsetOut = args.setByteOffsetOut || out.offset.toPrimitive();
      firstIndexOut = args.firstIndexOut || 0;
      strideByteLengthOut = args.strideByteLengthOut || out.parent.stride.toPrimitive();
      operation = new Object({
        begin,
        count,
        index,
        in0,
        setByteOffsetIn0,
        firstIndexIn0,
        strideByteLengthIn0,
        in1,
        setByteOffsetIn1,
        firstIndexIn1,
        strideByteLengthIn1,
        out,
        setByteOffsetOut,
        firstIndexOut,
        strideByteLengthOut,
        operator: Operator.from(operator)
      });
      return Object.assign(Operation.new(), operation);
    }

    getBuffer(col, first, stride) {
      var byteLength, byteOffset;
      byteOffset = first.toPrimitive() * stride.toPrimitive();
      byteLength = stride.toPrimitive() * this.count.toPrimitive();
      return col.target.parent.subbuffer(byteOffset, byteLength);
    }

    toWorker() {
      var bufIn0, bufIn1, worker;
      bufIn0 = this.getBuffer(this.in0, this.firstIndexIn0, this.strideByteLengthIn0);
      bufIn1 = this.getBuffer(this.in1, this.firstIndexIn1, this.strideByteLengthIn1);
      worker = new Worker(URL.createObjectURL(new Blob([this.toWorkerCode()], {
        type: "application/javascript"
      })));
      worker.onmessage = ({data}) => {
        var $lengthOut, $offsetOut, $strideOut, alias, count, getOffset, getter, iLE, reader, setOffset, setter, value, writer;
        if (!data) {
          throw /FAILED/;
        }
        iLE = DataView.prototype.isLittleEndian;
        count = this.count.toPrimitive();
        alias = this.out.getProperty("alias");
        $strideOut = this.strideByteLengthOut.toPrimitive();
        $offsetOut = this.setByteOffsetOut.toPrimitive();
        $lengthOut = $strideOut - $offsetOut;
        reader = new DataView(data);
        writer = this.out.target.parent.subdataview(this.firstIndexOut.toPrimitive(), $strideOut * count);
        getOffset = 0;
        setOffset = $offsetOut;
        getter = "get" + alias;
        setter = "set" + alias;
        while (count--) {
          value = reader[getter](getOffset, iLE);
          writer[setter](setOffset, value, iLE);
          getOffset += $lengthOut;
          setOffset += $strideOut;
        }
        log("done count:", this.count.toPrimitive());
        //todo release after dev: 
        return worker.terminate();
      };
      worker.postMessage({bufIn0, bufIn1}, [bufIn0, bufIn1]);
      return this;
    }

    toWorkerCode() {
      var $lengthOut, $offsetIn0, $offsetIn1, $offsetOut, $strideIn0, $strideIn1, $strideOut, alias, byteLength, count, iLE, operator;
      iLE = DataView.prototype.isLittleEndian;
      alias = this.out.getProperty("alias");
      count = this.count.toPrimitive();
      operator = this.operator.toString();
      $strideIn0 = this.strideByteLengthIn0.toPrimitive();
      $strideIn1 = this.strideByteLengthIn1.toPrimitive();
      $strideOut = this.strideByteLengthOut.toPrimitive();
      $offsetIn0 = this.setByteOffsetIn0.toPrimitive();
      $offsetIn1 = this.setByteOffsetIn1.toPrimitive();
      $offsetOut = this.setByteOffsetOut.toPrimitive();
      $lengthOut = $strideOut - $offsetOut;
      byteLength = $lengthOut * count;
      return ["", "self.addEventListener('message', function({data}){", "", "   let viewIn0 = new DataView( data.bufIn0 );", "   let viewIn1 = new DataView( data.bufIn1 );", "", `   let buffer = new ArrayBuffer( ${byteLength} );`, "   let writer = new DataView( buffer );", "", `   let count = ${count};`, "   let res = [];", "", "   let $in0;", `   let $offsetIn0 = ${$offsetIn0};`, `   let $strideIn0 = ${$strideIn0};`, "", "   let $in1;", `   let $offsetIn1 = ${$offsetIn1};`, `   let $strideIn1 = ${$strideIn1};`, "", "   let $offsetOut = 0;", "", `   $in0 = viewIn0.get${alias}( $offsetIn0, ${iLE} ); `, `   $in1 = viewIn1.get${alias}( $offsetIn1, ${iLE} ); `, "", "   while ( count-- )", "   {", `       writer.set${alias}( `, `           $offsetOut, ($in0 ${operator} $in1), ${iLE}`, "       );", "", `       res.push({ i: count, op: '${operator}', $in0, $in1, out:writer.get${alias}($offsetOut, ${iLE}) })`, "", $strideIn0 && `      $in0 = viewIn0.get${alias}( $offsetIn0, ${iLE} ); ` || "", $strideIn1 && `      $in1 = viewIn1.get${alias}( $offsetIn1, ${iLE} ); ` || "", "", `       $offsetOut += ${$lengthOut};`, $strideIn0 && `       $offsetIn0 += ${$strideIn0};` || "", $strideIn1 && `       $offsetIn1 += ${$strideIn1};` || "", "   }", "", "   //console.log(res.slice());", "   postMessage(buffer, [buffer]);", "});", "", ""].join("\n\t");
    }

  };

  Operation.classPointer = OPTR.ClassPointer.from(Operation);

  return Operation;

}).call(this);

Database.definePointer("name", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.StringPointer
});

Table.definePointer("base", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint8ArrayPointer
});

Table.definePointer("offset", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint32AtomicNumber
});

Table.definePointer("pages", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint32Number
});

Table.definePointer("stride", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Table.definePointer("name", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.StringPointer
});

Column.definePointer("byteLength", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Column.definePointer("offset", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Column.definePointer("instanceOf", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.ObjectPointer
});

Column.definePointer("name", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.StringPointer
});

Operation.definePointer("begin", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint32AtomicNumber
});

Operation.definePointer("count", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint32AtomicNumber
});

Operation.definePointer("index", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint32AtomicNumber
});

Operation.definePointer("in0", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.PointerLink
});

Operation.definePointer("firstIndexIn0", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Operation.definePointer("setByteOffsetIn0", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Operation.definePointer("strideByteLengthIn0", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Operation.definePointer("in1", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.PointerLink
});

Operation.definePointer("firstIndexIn1", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Operation.definePointer("setByteOffsetIn1", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Operation.definePointer("strideByteLengthIn1", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Operation.definePointer("out", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.PointerLink
});

Operation.definePointer("firstIndexOut", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Operation.definePointer("setByteOffsetOut", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Operation.definePointer("strideByteLengthOut", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Operation.definePointer("operator", {
  enumerable: true,
  isRequired: true,
  instanceOf: Operator
});

TypedAny.definePointer("type", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint8Number
});
