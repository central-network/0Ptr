var error, log, warn;

import * as OPTR from "./0ptr.min.js";

({log, warn, error} = console);

export var Database = (function() {
  class Database extends OPTR.ObjectPointer {
    static create(name) {
      return Object.assign(this.new(), {name});
    }

    createTable(name, pages) {
      return this.appendChild(Object.assign(Table.new(), {
        pages,
        name,
        base: OPTR.Uint8ArrayPointer.from(pages * 654)
      }));
    }

    createOperation() {
      return Operation.from(...arguments);
    }

    parseColumns({columns = "*"}, tables = {}) {
      var alias, c, colName, columnName, columnNames, j, k, len, len1, matchs, ref, t, tAlias, table, tableAlias, tablesColumns;
      if (columns.match(/\*/)) {
        tablesColumns = [];
        for (tAlias in tables) {
          t = tables[tAlias];
          ref = t.children;
          for (j = 0, len = ref.length; j < len; j++) {
            c = ref[j];
            tablesColumns.push(`${tAlias}.${c.name.toPrimitive()}`);
          }
        }
        columns = columns.replace(/\*/g, tablesColumns.join(","));
      }
      columnNames = columns.split(/\,/);
      columnNames = columnNames.map(function(t) {
        return t.trim();
      });
      columnNames = columnNames.filter(function(c, i) {
        return columnNames.indexOf(c) === i;
      });
      columnNames = columnNames.filter(Boolean);
      columns = new Object;
      for (k = 0, len1 = columnNames.length; k < len1; k++) {
        columnName = columnNames[k];
        tableAlias = "";
        if (columnName.match(/\./)) {
          [tableAlias, colName] = columnName.split(/\./g).map(function(n) {
            return n.trim();
          }).filter(Boolean);
          if (!colName) {
            throw /TBL.COLNAME_COLMNFAILED/;
          }
          if (!tables[tableAlias]) {
            throw /TBL.COLNAME_TABLEFAILED/;
          }
          columnName = colName;
        }
        [colName, alias] = columnName.replace(/\s+|as/g, " ").split(/\s+/g);
        alias || (alias = colName);
        if (tableAlias) {
          columns[`${tableAlias}.${alias}`] = tables[tableAlias].children.find(function(c) {
            return c.name.eq(colName);
          });
          continue;
        }
        matchs = this.filter(function(t) {
          return t.find(function(c) {
            return c.name.eq(colName);
          });
        });
        switch (matchs.length) {
          case 1:
            tableAlias = matchs[0].name.toPrimitive();
            break;
          case 0:
            throw /TBLNOTFOUND_USEDCOLMNS/;
          default:
            retunr((function() {
              throw /COLMNMATCHS_MULTITABLE/;
            })());
        }
        table = tables[tableAlias] || matchs.at(0);
        if (!(columns[`${tableAlias}.${alias}`] = table.children.find(function(c) {
          return c.name.eq(colName);
        }))) {
          throw /TBLFORCOL_NOTFOUND/;
        }
      }
      return columns;
    }

    parseTables({tables = ""}) {
      var alias, dbName, j, len, table, tableName, tableNames;
      tableNames = tables.split(/\,/);
      tableNames = tableNames.map(function(t) {
        return t.trim();
      });
      tableNames = tableNames.filter(Boolean);
      if (!tableNames.length) {
        throw /FROMARG_REQUIRED/;
      }
      tables = new Object;
      for (j = 0, len = tableNames.length; j < len; j++) {
        tableName = tableNames[j];
        [dbName, alias] = tableName.replace(/\s+|as/g, " ").split(/\s+/g);
        if (!alias) {
          alias = dbName;
        }
        if (!(table = this.find(function(t) {
          return t.name.eq(dbName);
        }))) {
          throw /TBL_NOTFOUND/;
        }
        tables[alias] = table;
      }
      return tables;
    }

    parseRules({rules = []}, columns, tables) {
      var alias, any, closed, contents, end, ends, getAny, getColumn, getNumber, i, index, j, k, l, len, len1, len2, len3, len4, len5, m, next, o, opened, p, p0, p1, part, part0, part1, parts, partsAll, partsSliced, prev, ref, ref1, ref2, rule, ruleindex, ruleset, start, starts;
      ruleset = new Array;
      contents = new Array;
      getColumn = function(any) {
        var c, column;
        if (columns[any]) {
          return columns[any];
        }
        for (c in columns) {
          column = columns[c];
          if (column.name.eq(any)) {
            return column;
          }
        }
        for (c in columns) {
          column = columns[c];
          if (c.split(".").at(-1) === any) {
            return column;
          }
        }
        return void 0;
      };
      getNumber = function(any) {
        var number;
        if (isNaN(any)) {
          return;
        }
        number = Number(any);
        if (!Number.isInteger(number)) {
          return OPTR.Float32Number.from(number);
        }
        return OPTR.Int32Number.from(number);
      };
      getAny = function(any) {
        return Comparator.fromMatch(any) || Operator.fromMatch(any) || Mathematics.fromMatch(any) || getNumber(any) || getColumn(any);
      };
      for (ruleindex = j = 0, len = rules.length; j < len; ruleindex = ++j) {
        rule = rules[ruleindex];
        rule = `(${rule})`;
        parts = [];
        starts = [];
        ends = [];
        start = -1;
        end = rule.length + 1;
        opened = true;
        closed = true;
        while (opened || closed) {
          start = rule.indexOf("(", start + 1);
          end = rule.lastIndexOf(")", end - 1);
          opened = start !== -1;
          closed = end !== -1;
          if (opened) {
            starts.push(start);
          }
          if (closed) {
            ends.unshift(end);
          }
        }
        if (starts.length - ends.length) {
          throw [/RULEERR_PARANTHESIS/, rule, starts, ends];
        }
        ref = starts.reverse();
        for (i = k = 0, len1 = ref.length; k < len1; i = ++k) {
          start = ref[i];
          alias = "$part" + i;
          index = ends.findIndex(function(i) {
            return i > start;
          });
          end = ends.splice(index, 1).at(0);
          prev = rule.substring(0, start + 1);
          next = rule.substring(end);
          parts.push({
            start,
            end,
            alias,
            text: rule.substring(start + 1, end),
            prev,
            next
          });
        }
        partsSliced = parts.slice(0);
        partsAll = partsSliced.slice();
        for (p0 = l = 0, len2 = partsSliced.length; l < len2; p0 = ++l) {
          part0 = partsSliced[p0];
          ref1 = partsSliced.slice(p0);
          for (p1 = m = 0, len3 = ref1.length; m < len3; p1 = ++m) {
            part1 = ref1[p1];
            part1.subs || (part1.subs = []);
            if (part0.start > part1.start) {
              if (part0.end < part1.end) {
                part1.subs.push(part0);
                part0.parent = part1;
                break;
              }
            }
          }
        }
        parts = parts.at(-1).subs;
        for (i = o = 0, len4 = partsAll.length; o < len4; i = ++o) {
          part = partsAll[i];
          part.contents = [];
          ref2 = part.text.split(/\s+|\(|\)/g).filter(Boolean);
          for (p = 0, len5 = ref2.length; p < len5; p++) {
            any = ref2[p];
            part.contents.push(contents[contents.length] = {
              any: any,
              part: part,
              match: getAny(any)
            });
          }
        }
        ruleset.push({
          rule: rule.substring(1, rule.length - 1),
          parts,
          partsAll
        });
      }
      log(ruleset);
      log(columns);
      log(contents);
      return ruleset;
    }

    query(options = {}) {
      var column, columnAlias, columnName, columns, get, i, index, j, len, results, row, rows, rule, rules, table, tableAlias, tables, value;
      tables = this.parseTables(options);
      columns = this.parseColumns(options, tables);
      rules = this.parseRules(options, columns, tables);
      if (Object.keys(tables).length === 1) {
        for (columnAlias in columns) {
          column = columns[columnAlias];
          columns[columnAlias.split(".")[1]] = column;
          delete columns[columnAlias];
        }
      }
      results = [];
      index = 0;
      for (tableAlias in tables) {
        table = tables[tableAlias];
        rows = table.count;
        i = 0;
        while (i < rows) {
          get = table.get(i++);
          row = {};
          for (columnAlias in columns) {
            column = columns[columnAlias];
            columnName = column.name.toPrimitive();
            row[columnAlias] = get[columnName];
          }
          for (j = 0, len = rules.length; j < len; j++) {
            rule = rules[j];
            for (columnAlias in row) {
              value = row[columnAlias];
              //todo replace value with alias and filter
              1;
            }
          }
          results[index++] = row;
        }
      }
      return results;
    }

  };

  Database.classPointer = OPTR.ClassPointer.from(Database);

  return Database;

}).call(this);

export var Column = (function() {
  class Column extends OPTR.ObjectPointer {
    static from(options = {}) {
      var key, ptrc, ptri, val;
      ptri = this.new();
      ptrc = this.classPointer;
      for (key in options) {
        val = options[key];
        ptri[key] = ptrc.getProperty(key).from(val);
      }
      return ptri;
    }

    getProperty() {
      return this.instanceOf.getProperty(...arguments);
    }

  };

  Column.classPointer = OPTR.ClassPointer.from(Column);

  return Column;

}).call(this);

export var Row = class Row extends Object {};

export var Rule = class Rule extends OPTR.ObjectPointer {};

export var RuleSet = class RuleSet extends OPTR.ObjectPointer {};

export var Table = (function() {
  class Table extends OPTR.ObjectPointer {
    createColumn(name, instanceOf, byteLength) {
      return this.appendChild(Column.from({
        name,
        instanceOf,
        byteLength,
        offset: this.addStride(4)
      }));
    }

    addStride(byteLength = 0) {
      var offset;
      this.stride = byteLength + (offset = this.stride.toPrimitive());
      return offset;
    }

    getColumn(any) {
      if (!isNaN(any)) {
        return this.children[i];
      }
      return this.find(function(c) {
        return c.name.eq(any);
      });
    }

    get(index = 0) {
      var alias, basedv, byteLength, byteOffset, col, j, len, offset, ref, result;
      byteLength = this.stride.toPrimitive();
      byteOffset = byteLength * index;
      basedv = this.base.dataView(byteOffset, byteLength);
      Object.defineProperties(result = new Row, {
        index: {
          value: index
        },
        byteOffset: {
          value: byteOffset
        },
        byteLength: {
          value: byteLength
        }
      });
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        col = ref[j];
        alias = col.instanceOf.getProperty("alias");
        offset = col.offset.toPrimitive();
        result[col.name.toPrimitive()] = basedv.get(alias, offset);
      }
      return result;
    }

    subdataview(byteOffset = 0, byteLength) {
      byteLength || (byteLength = this.byteLength - byteOffset);
      return this.base.dataView(byteOffset, byteLength);
    }

    subbuffer(byteOffset = 0, byteLength) {
      byteLength || (byteLength = this.byteLength - byteOffset);
      return this.base.subarray(byteOffset, byteLength).slice().buffer;
    }

    subarray(byteOffset = 0, byteLength) {
      byteLength || (byteLength = this.byteLength - byteOffset);
      return this.base.subarray(byteOffset, byteLength);
    }

    insert(values = {}) {
      var alias, basedv, col, j, key, len, offset, ref, stride, value;
      stride = this.stride.toPrimitive();
      offset = this.offset.add(stride);
      basedv = this.base.dataView(offset, stride);
      ref = Object.keys(values);
      for (j = 0, len = ref.length; j < len; j++) {
        key = ref[j];
        col = this.getColumn(key);
        value = values[key];
        alias = col.instanceOf.getProperty("alias");
        basedv.set(alias, col.offset.toPrimitive(), value);
      }
      return offset / stride;
    }

  };

  Table.classPointer = OPTR.ClassPointer.from(Table);

  Object.defineProperty(Table.prototype, "byteLength", {
    get: function() {
      return this.pages.toPrimitive() * 654;
    }
  });

  Object.defineProperty(Table.prototype, "count", {
    get: function() {
      return this.offset.toPrimitive() / this.stride.toPrimitive();
    }
  });

  return Table;

}).call(this);

export var TypedAny = (function() {
  class TypedAny extends OPTR.ObjectPointer {
    static from(any) {
      var type;
      if (1 > (type = this.definitions.indexOf(any))) {
        throw /UNDEFINED_ANY/;
      }
      return Object.assign(this.new(), {type});
    }

    static fromMatch(any) {
      if (0 < this.definitions.indexOf(any.toUpperCase())) {
        return this.from(any);
      }
      return void 0;
    }

    toPrimitive() {
      return this.constructor.definitions[this.type];
    }

  };

  TypedAny.classPointer = OPTR.ClassPointer.from(TypedAny);

  TypedAny.definitions = [0/0];

  Object.defineProperty(TypedAny.prototype, "children", {
    enumerable: false,
    value: []
  });

  Object.defineProperty(TypedAny.prototype, "valueKey", {
    enumerable: true,
    get: function() {
      return this.toPrimitive();
    }
  });

  return TypedAny;

}).call(this);

export var Mathematics = (function() {
  class Mathematics extends TypedAny {};

  Mathematics.classPointer = OPTR.ClassPointer.from(Mathematics);

  Mathematics.definitions = [0/0, "SUM", "AVG", "MED", "MAX", "MIN", "POW"];

  return Mathematics;

}).call(this);

export var Comparator = (function() {
  class Comparator extends TypedAny {};

  Comparator.classPointer = OPTR.ClassPointer.from(Comparator);

  Comparator.definitions = [0/0, "<", ">", "=", ">=", "<=", "!=", "<>"];

  return Comparator;

}).call(this);

export var Operator = (function() {
  class Operator extends TypedAny {};

  Operator.classPointer = OPTR.ClassPointer.from(Operator);

  Operator.definitions = [0/0, "+", "-", "*", "/", "%"];

  return Operator;

}).call(this);

export var Operation = (function() {
  class Operation extends OPTR.ObjectPointer {
    static from(args = {}) {
      var begin, count, firstIndexIn0, firstIndexIn1, firstIndexOut, in0, in1, index, operation, operator, out, setByteOffsetIn0, setByteOffsetIn1, setByteOffsetOut, strideByteLengthIn0, strideByteLengthIn1, strideByteLengthOut;
      ({in0, in1, out, operator, begin = 0, count = 0, index = 0} = args);
      setByteOffsetIn0 = args.setByteOffsetIn0 || in0.offset.toPrimitive();
      firstIndexIn0 = args.firstIndexIn0 || 0;
      strideByteLengthIn0 = args.strideByteLengthIn0 || in0.parent.stride.toPrimitive();
      setByteOffsetIn1 = args.setByteOffsetIn1 || in1.offset.toPrimitive();
      firstIndexIn1 = args.firstIndexIn1 || 0;
      strideByteLengthIn1 = args.strideByteLengthIn1 || in1.parent.stride.toPrimitive();
      setByteOffsetOut = args.setByteOffsetOut || out.offset.toPrimitive();
      firstIndexOut = args.firstIndexOut || 0;
      strideByteLengthOut = args.strideByteLengthOut || out.parent.stride.toPrimitive();
      operation = new Object({
        begin,
        count,
        index,
        in0,
        setByteOffsetIn0,
        firstIndexIn0,
        strideByteLengthIn0,
        in1,
        setByteOffsetIn1,
        firstIndexIn1,
        strideByteLengthIn1,
        out,
        setByteOffsetOut,
        firstIndexOut,
        strideByteLengthOut,
        operator: Operator.from(operator)
      });
      return Object.assign(Operation.new(), operation);
    }

    getBuffer(col, first, stride) {
      var byteLength, byteOffset;
      byteOffset = first.toPrimitive() * stride.toPrimitive();
      byteLength = stride.toPrimitive() * this.count.toPrimitive();
      return col.target.parent.subbuffer(byteOffset, byteLength);
    }

    toWorker() {
      var bufIn0, bufIn1, worker;
      bufIn0 = this.getBuffer(this.in0, this.firstIndexIn0, this.strideByteLengthIn0);
      bufIn1 = this.getBuffer(this.in1, this.firstIndexIn1, this.strideByteLengthIn1);
      worker = new Worker(URL.createObjectURL(new Blob([this.toWorkerCode()], {
        type: "application/javascript"
      })));
      worker.onmessage = ({data}) => {
        var $lengthOut, $offsetOut, $strideOut, alias, count, getOffset, getter, iLE, reader, setOffset, setter, value, writer;
        if (!data) {
          throw /FAILED/;
        }
        iLE = DataView.prototype.isLittleEndian;
        count = this.count.toPrimitive();
        alias = this.out.getProperty("alias");
        $strideOut = this.strideByteLengthOut.toPrimitive();
        $offsetOut = this.setByteOffsetOut.toPrimitive();
        $lengthOut = $strideOut - $offsetOut;
        reader = new DataView(data);
        writer = this.out.target.parent.subdataview(this.firstIndexOut.toPrimitive(), $strideOut * count);
        getOffset = 0;
        setOffset = $offsetOut;
        getter = "get" + alias;
        setter = "set" + alias;
        while (count--) {
          value = reader[getter](getOffset, iLE);
          writer[setter](setOffset, value, iLE);
          getOffset += $lengthOut;
          setOffset += $strideOut;
        }
        log("done count:", this.count.toPrimitive());
        //todo release after dev: 
        return worker.terminate();
      };
      worker.postMessage({bufIn0, bufIn1}, [bufIn0, bufIn1]);
      return this;
    }

    toWorkerCode() {
      var $lengthOut, $offsetIn0, $offsetIn1, $offsetOut, $strideIn0, $strideIn1, $strideOut, alias, byteLength, count, iLE, operator;
      iLE = DataView.prototype.isLittleEndian;
      alias = this.out.getProperty("alias");
      count = this.count.toPrimitive();
      operator = this.operator.toString();
      $strideIn0 = this.strideByteLengthIn0.toPrimitive();
      $strideIn1 = this.strideByteLengthIn1.toPrimitive();
      $strideOut = this.strideByteLengthOut.toPrimitive();
      $offsetIn0 = this.setByteOffsetIn0.toPrimitive();
      $offsetIn1 = this.setByteOffsetIn1.toPrimitive();
      $offsetOut = this.setByteOffsetOut.toPrimitive();
      $lengthOut = $strideOut - $offsetOut;
      byteLength = $lengthOut * count;
      return ["", "self.addEventListener('message', function({data}){", "", "   let viewIn0 = new DataView( data.bufIn0 );", "   let viewIn1 = new DataView( data.bufIn1 );", "", `   let buffer = new ArrayBuffer( ${byteLength} );`, "   let writer = new DataView( buffer );", "", `   let count = ${count};`, "   let res = [];", "", "   let $in0;", `   let $offsetIn0 = ${$offsetIn0};`, `   let $strideIn0 = ${$strideIn0};`, "", "   let $in1;", `   let $offsetIn1 = ${$offsetIn1};`, `   let $strideIn1 = ${$strideIn1};`, "", "   let $offsetOut = 0;", "", `   $in0 = viewIn0.get${alias}( $offsetIn0, ${iLE} ); `, `   $in1 = viewIn1.get${alias}( $offsetIn1, ${iLE} ); `, "", "   while ( count-- )", "   {", `       writer.set${alias}( `, `           $offsetOut, ($in0 ${operator} $in1), ${iLE}`, "       );", "", `       res.push({ i: count, op: '${operator}', $in0, $in1, out:writer.get${alias}($offsetOut, ${iLE}) })`, "", $strideIn0 && `      $in0 = viewIn0.get${alias}( $offsetIn0, ${iLE} ); ` || "", $strideIn1 && `      $in1 = viewIn1.get${alias}( $offsetIn1, ${iLE} ); ` || "", "", `       $offsetOut += ${$lengthOut};`, $strideIn0 && `       $offsetIn0 += ${$strideIn0};` || "", $strideIn1 && `       $offsetIn1 += ${$strideIn1};` || "", "   }", "", "   //console.log(res.slice());", "   postMessage(buffer, [buffer]);", "});", "", ""].join("\n\t");
    }

  };

  Operation.classPointer = OPTR.ClassPointer.from(Operation);

  return Operation;

}).call(this);

Database.definePointer("name", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.StringPointer
});

Table.definePointer("base", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint8ArrayPointer
});

Table.definePointer("offset", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint32AtomicNumber
});

Table.definePointer("pages", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint32Number
});

Table.definePointer("stride", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Table.definePointer("name", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.StringPointer
});

Column.definePointer("byteLength", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Column.definePointer("offset", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Column.definePointer("instanceOf", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.ObjectPointer
});

Column.definePointer("name", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.StringPointer
});

Operation.definePointer("begin", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint32AtomicNumber
});

Operation.definePointer("count", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint32AtomicNumber
});

Operation.definePointer("index", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint32AtomicNumber
});

Operation.definePointer("in0", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.PointerLink
});

Operation.definePointer("firstIndexIn0", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Operation.definePointer("setByteOffsetIn0", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Operation.definePointer("strideByteLengthIn0", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Operation.definePointer("in1", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.PointerLink
});

Operation.definePointer("firstIndexIn1", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Operation.definePointer("setByteOffsetIn1", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Operation.definePointer("strideByteLengthIn1", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Operation.definePointer("out", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.PointerLink
});

Operation.definePointer("firstIndexOut", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Operation.definePointer("setByteOffsetOut", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Operation.definePointer("strideByteLengthOut", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint16Number
});

Operation.definePointer("operator", {
  enumerable: true,
  isRequired: true,
  instanceOf: Operator
});

TypedAny.definePointer("type", {
  enumerable: true,
  isRequired: true,
  instanceOf: OPTR.Uint8Number
});
